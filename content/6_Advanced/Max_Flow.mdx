---
id: max-flow
title: 'Maximum Flow'
author: Benjamin Qi
prerequisites:
  - unweighted-shortest-paths
description: Introduces maximum flow as well as flow with lower bounds.
frequency: 1
---

<Problems problems="maxSam" />

## Solution

The code below uses the [Ford-Fulkerson](https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm) algorithm.

The solution is a greedy approach. The download speed - the flow - can be improved as long as we can find a non-negative capacity path from the source - the server and the sink - Kotivalo's computer. After that we substract the minimum capacity on the found path from the edge capacities.

<LanguageSection>
<CPPSection>
```cpp
#include <bits/stdc++.h>

using namespace std;

const int NMAX = 500;

long long max_flow(vector<vector<long long>> g, int n, int source, int sink) {
	long long flow = 0;
	vector<int> parent(n, -1);

	// Find a wat from source to sink with non-negetive capacities
	auto reachable = [&]() -> bool {
		queue<int> q;
		q.push(source);
		while(!q.empty()) {
			int node = q.front();
			q.pop();
			for(int son = 0; son < n; son++) {
				long long w = g[node][son];
				if(w <= 0 || parent[son] != -1) continue ;
				parent[son] = node;
				q.push(son);
			}			
		}
		return parent[sink] != -1;
	};

	// While there is a way from source to sink with non-negative capacities
	while(reachable()) {
		int node = sink;

		// The minimum capacity on the path from source to sink 
		long long curr_flow = LLONG_MAX;
		while(node != source) {
			curr_flow = min(curr_flow, g[parent[node]][node]);
			node = parent[node];
		}
		node = sink;
		while(node != source) {
			// Substract the capacity from capacity edges
			g[parent[node]][node] -= curr_flow;
			// Add the current flow to flow backedges
			g[node][parent[node]] += curr_flow;
			node = parent[node];
		}
		flow += curr_flow;
		fill(parent.begin(), parent.end(), -1);
	}
	return flow;
}

vector<vector<long long>> capacity(NMAX, vector<long long>(NMAX, 0));
int main() {
	int n, m;
	cin >> n >> m;
	for(int i = 0; i < m; i++) {
		int x, y, c;
		cin >> x >> y >> c;
		x--, y--;
		capacity[x][y] += c;
	}

	cout << max_flow(capacity, n, 0, n-1) << endl;

	return 0;
}
```
</CPPSection>
</LanguageSection>

## Resources

<Resources>
	<Resource
		source="CPC"
		title="10 - Network Flow"
		url="10_graphs_3_network_flow"
	/>
	<Resource source="CPH" title="20 - Flows & Cuts"/>
	<Resource
		source="CP2"
		title="4.6, 4.7.4 - Max Flow, Bipartite Graphs"
	 />
</Resources>

## Flows

<Problems problems="flow" />

## Bipartite Matching

<Problems problems="match" />

## Dinic's Algorithm

<YouTube id="M6cm8UeeziI" />

<Problems problems="dinic" />

Hopcroft-Karp Bipartite Matching?

<Optional title="Faster Flow">

There exist faster flow algorithms such as **Push-Relabel**. Also see the
following blog post:

- [Chilli: Dinic's with Scaling](https://codeforces.com/blog/entry/66006)

However, the standard implementation of Dinic's is (almost) always fast enough
on reasonable problems.

</Optional>

### Implementation

<Resources>
	<Resource
		source="Benq"
		url="https://github.com/bqi343/USACO/blob/master/Implementations/content/graphs%20(12)/Flows%20(12.3)/Dinic.h"
		title="Dinic"
	/>
</Resources>

## Breaking Flows

When the constraints are too high ...

<Resources>
	<Resource
		source="CF"
		url="https://codeforces.com/blog/entry/80627"
		title="maroonrk - TL Issue on CF 659 Div 1 F"
		starred
	/>
	<Resource
		source="CF"
		url="https://codeforces.com/blog/entry/52714?#comment-668566"
		title="Actual Complexity of Max Flow?"
		starred
	/>
</Resources>
