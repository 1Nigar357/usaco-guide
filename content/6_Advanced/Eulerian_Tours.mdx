---
id: eulerian-tours
title: 'Eulerian Tours'
author: Benjamin Qi
prerequisites:
  - graph-traversal
description: Visiting all edges of a graph exactly once.
frequency: 0
---

Mentioned in USACO Training ...

<Problems problems="sam" />

## Resources

<Resources>
	<Resource source="CPH" title="19.1 - Eulerian Tours" />
	<Resource source="CP2" title="4.7.3 - Eulerian Graph" />
</Resources>

## Implementation

### Mail Delivery

First let's define what is an **Eulerian** path: ``A path that goes through every edge once.``. Similarly, an **Eulerian cycle** is an Eulerian starts and ends
with the same node.

An important condition for a graph to be an Eulerian cycle is: ``A graph can be an Eulerian graph if and only if every node has an even degree.``

Now, to properly find the Eulerian cycle we run a slightly modified DFS. The DFS goes through only unvisited edges and the same edge can be processe multiple times throuoght the DFs, so we remove it from the graph at the first visit.

The algorithm described above is called the [Hierholzer's Algorithm](https://en.wikipedia.org/wiki/Eulerian_path).

<CodeSection>
<CPPSection>
```cpp 
#include <bits/stdc++.h>
using namespace std;

int n, m;
vector<vector<pair<int, int>>> g;
vector<int> degree, path;
vector<bool> seen;

void dfs(int node) {
    while(!g[node].empty()) {
        auto [son, idx] = g[node].back();
        g[node].pop_back();
        if(seen[idx]) continue;
        seen[idx] = true;
        dfs(son);
    }
    path.push_back(node);
}

int main() {
    cin >> n >> m;

    g.resize(n);
    degree.resize(n);
    seen.resize(m);

    for(int i = 0; i < m; i++) {
        int x, y;
        cin >> x >> y;
        x--, y--;
        g[x].push_back({y, i});
        g[y].push_back({x, i});
        degree[x]++;
        degree[y]++;
    }

    for(int node = 0; node < n; node++) {
        if(degree[node] % 2) {
            cout << "IMPOSSIBLE";
            return 0;
        }
    }

    dfs(0);

    if(path.size() != m+1) {
        cout << "IMPOSSIBLE";
    } else {
        for(auto node : path) {
            cout << node+1 << ' ';
        }
    }
    return 0;
}   
```
</CPPSection>
</CodeSection>

### Teleporters

<CodeSection>
<CPPSection>
```cpp 
#include <bits/stdc++.h>
using namespace std;

int n, m;
vector<vector<int>> g;
vector<int> in, out, path;

void dfs(int node) {
    while(!g[node].empty()) {
        int son = g[node].back();
        g[node].pop_back();
        dfs(son);
    }
    path.push_back(node);
}

int main() {
    cin >> n >> m;

    g.resize(n+1);
    in.resize(n+1);
    out.resize(n+1);

    for(int i = 0; i < m; i++) {
        int x, y;
        cin >> x >> y;
        g[x].push_back(y);
        out[x]++;
        in[y]++;
    }

    bool flag = true;
    for(int node = 2; node < n && flag; node++) {
        if(in[node] != out[node]) {
            flag = false;
        }
    }
    if(out[1] != in[1]+1 || out[n] != in[n]-1 || !flag) {
        cout << "IMPOSSIBLE";
        return 0;
    }

    dfs(1);
    
    reverse(path.begin(), path.end());
    if(path.size() != m+1 || path.back() != n) {
        cout << "IMPOSSIBLE";
    } else {
        for(auto node : path) {
            cout << node << ' ';
        }
    }

    return 0;
}   
```
</CPPSection>
</CodeSection>

## Problems

<Problems problems="general" />
