---
id: game-theory
title: 'Game Theory'
author: Benjamin Qi
contributors: Salma J
description: 'Solving games that are usually two-player to find the winner.'
frequency: 0
---

<Resources>
    <Resource
    	source="TopCoder"
    	title="Algorithm Games"
    	url="https://www.topcoder.com/community/data-science/data-science-tutorials/algorithm-games/"
    	starred
    />
    <Resource
    	source="John H. Conway"
    	title="On Algorithms and Games"
    	url="https://sites.math.rutgers.edu/~zeilberg/EM13/onag1.pdf"
    	starred
    />
    <Resource
    	source="E. R. Berlekamp"
    	title="Winning Ways for Your Mathematical Plays"
    	url="https://bobson.ludost.net/copycrime/Winning%20Ways%202nd%20Edition/Winning.Ways.for.Your.Mathematical.Plays.V3--1568811438.pdf"
    	starred
    />
    <Resource
    	source="CP-algorithms"
    	title="Games on Graphs"
    	url="https://cp-algorithms.com/game_theory/games_on_graphs.html"
    />
    <Resource
    	source="CP-algorithms"
    	title="Sprague-Grundy Theorem & Nim"
    	url="https://cp-algorithms.com/game_theory/sprague-grundy-nim.html"
    />
</Resources>

## NIM Game

<ProblemFocus problem="nim" />

### Game description

The most well-known impartial game is the NIM game. In this game there are considered $n$ piles with stones. At every step, a player removes a non-zero number of stone from a pile. 
The game continues while there are stones left. The winner is the player that makes the last move.

Let's denote a state of the game as ${x_1, x_2, x_3, \ldots, x_n}$, where $x_i$ is the number of stones left in pile $i$. Then the winning strategy is as following:
$$
\text{The current player has a winning strategy if and only if the xor0sum of the pile sizes is not } 0
$$

The xor sum is $x_1 \oplus x_2 \oplus x_3 \ldots \oplus x_n$, where $\oplus$ denotes the [bitwise exclusive xor](/adv/xor-basis).

### Demonstration

To demonstrate this theory we have to show that from a state with xor-sum $0$ (losing), whatever the move is, we can only reach a state with non-zero xox-sum (winning), and from a winning state we can reach a losing state.

We will assume that from a state with sum-xor $0$ we can also reach another state with xor-sum $0$. Let's pick an arbitrary pile with $y$ stones and we would like to remove $x$ stones ($x \in [1, y]$). 
Denote $s$ as the xor-sum of the other $n-1$ piles, then we have $s \oplus y = 0 \iff s = y$. By removing $x$ stones from the pile, to reach a zero xor-sum state, means that $s \oplus (y - x) = 0 \iff s = y - x$. We demonstrated that $s = y$ so $s = y - x \iff y = y - x \iff x = 0$ which is false, because we can't remove $0$ stones i.e $x \in [1,y]$. 

It remains to demonstrate that from a winning state we can bring the other player in a losing state. Let $s$ be the xor-sum of all the pile sizes. If there is a pile with $y$ stone such that $y \gt y \oplus s$, then we can remove $y - y \oplus s$ stones from this pile, remaining $y - (y - y \oplus s) = y \plus s$. Now the pile has $y \oplus s$ stones. Consequently, if there is such a pile we can reach a losing state from a winning state.

<LanguageSection>
<CPPSection>
```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() { 
	int t;
	cin >> t;
	while(t--) {
		int n, s = 0;
		cin >> n;
		for(int i = 0; i < n; i++) {
			int x;
			cin >> x;
			s ^= x;
		}
		cout << (s == 0 ? "second" : "first") << '\n';
	}
	return 0;
}
```
</CPPSection>
</LanguageSection>

## Problems

<Problems problems="general" />
