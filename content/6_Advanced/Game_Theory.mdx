---
id: game-theory
title: 'Game Theory'
author: Benjamin Qi, Mihnea Brebenel
contributors: Salma J
description: 'Solving games that are usually two-player to find the winner.'
frequency: 0
---

<Resources>
    <Resource
    	source="TopCoder"
    	title="Algorithm Games"
    	url="https://www.topcoder.com/community/data-science/data-science-tutorials/algorithm-games/"
    	starred
    />
    <Resource
    	source="John H. Conway"
    	title="On Algorithms and Games"
    	url="https://sites.math.rutgers.edu/~zeilberg/EM13/onag1.pdf"
    	starred
    />
    <Resource
    	source="E. R. Berlekamp"
    	title="Winning Ways for Your Mathematical Plays"
    	url="https://bobson.ludost.net/copycrime/Winning%20Ways%202nd%20Edition/Winning.Ways.for.Your.Mathematical.Plays.V3--1568811438.pdf"
    	starred
    />
    <Resource
    	source="CP-algorithms"
    	title="Games on Graphs"
    	url="https://cp-algorithms.com/game_theory/games_on_graphs.html"
    />
    <Resource
    	source="CP-algorithms"
    	title="Sprague-Grundy Theorem & Nim"
    	url="https://cp-algorithms.com/game_theory/sprague-grundy-nim.html"
    />
</Resources>

## Nim

<FocusProblem problem="nim" />

### Game description

Nim might be one of the most well-known examples in game theory.
In this game there are considered $n$ piles of some item.
The problem uses sticks, while some others use stones; we'll be using sticks to stay
consistent with the CSES problem.
Regardless, players take turns removing a nonzero number of sticks from a certain pile,
and the player who takes the last stick wins.

Let's represent the current state of the piles with $[x_1, x_2, x_3, \ldots, x_n]$,
where $x_i$ is the number of sticks in pile $i$.
You'll soon see that it doesn't matter whether we include empty piles in our array.

We now propose something that may seem unintuitive at first:

> The player who moves first can always win if the xor-sum of the sizes of the piles is nonzero.

### Proof

For our own sanity, we'll refer to a state with a xor-sum of 0 as a "losing state"
and a state with a nonzero xor-sum as a "winning state."

To prove this, we have to show that from a losing state, any move we make
will result in a winning state and vice versa.
Notice that when we make our move, the game switches to a "sub-game" of sorts
where the second player becomes the first player.
Thus, moving to a winning state for the next turn means that they win and we lose.

However, it's probably good to prove our base cases first.
$[0]$ is a losing state, since the first player can't make any moves and thus loses.
On the other hand, $[x]$ where $x$ is any positive integer is a winning state since
we can take $x$ sticks from the only pile.
As we can see, the first state has a xor-sum of $0$ while the second has a xor-sum of $x$ which is nonzero.

#### Losing $\rightarrow$ Winning

Let's first prove that any losing state will move to a winning state for the other player.

Since XOR is a commutative and associative operation, we can assume WLOG that the move we make is on pile $1$.

The current xor-sum of the state is $x_1 \oplus x_2 \oplus \cdots x_n=0$.
Notice that this can be thought of $x_1$ XOR the xor-sum of the rest of the numbers.
Let's call that xor-sum of everything else $y$.

Since the xor-sum is $0$, $x_1=y$.
Removing any number of sticks from $x_1$ will break this equality and turn
$x_1 \oplus y$ nonzero, which is precisely the definition for our winning state.

#### Winning $\rightarrow$ Losing

Now we have to prove that any *winning* state can move to a losing state for the other player.
Notice the use of *can* instead of *will* in our statement due to how these games work.

This time, let's define $y$ as the xor-sum of *all* the piles instead of all except for one.
Then, say we have an $x_i$ such that $x_i > y \oplus x_i$.
Note that $y \oplus x_i$ is the xor-sum of all the other elements, since XOR is its own inverse.

With this, we can take $x_i - (y \oplus x_i)$ sticks from $x_i$, then makes it equivalent to $y \oplus x_i$
and the xor-sum of the whole board will be $0$, thus forming a losing state for the second player.

But all of this hinges on the existence of an $x_i$ such that $x_i > y \oplus x_i$.
Does it *always* exist?

Suppose that $p$ is the position of the most significant bit in $y$.
Then, we know that there must exist some $x_i$ with a set bit at $p$ as well.
Whether $p$ is the most significant bit in $x_i$ or not, XOR-ing the two gives
a result with a $0$ at bit $p$.
This then guarantees that there exists an $x_i > y \oplus x_i$.

<center>

| Variable | Value |
|------|------|
| $y$    | `0...01?...?` |
| $x_i$ | `?...?1?...?` |
| $y \oplus x_i$ | `?...?0?...?` |

*Since the first part of $y$ is all `0`s, the first parts of $x_i$ and $y \oplus x_i$ are the same.*

</center>

### Implementation

**Time Complexity:** $\mathcal{O}(N)$

<LanguageSection>
<CPPSection>

```cpp
#include <iostream>
#include <vector>

using std::cout;
using std::endl;
using std::vector;

int main() {
	int test_num;
	std::cin >> test_num;
	for (int t = 0; t < test_num; t++) {
		int pile_num;
		std::cin >> pile_num;
		vector<int> piles(pile_num);
		for (int& p : piles) {
			std::cin >> p;
		}

		int xor_sum = 0;
		for (int p : piles) {
			xor_sum ^= p;
		}

		cout << (xor_sum != 0 ? "first" : "second") << '\n';
	}
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader read = new BufferedReader(new InputStreamReader(System.in));
		int testNum = Integer.parseInt(read.readLine());
		for (int t = 0; t < testNum; t++) {
			int pileNum = Integer.parseInt(read.readLine());
			StringTokenizer pileST = new StringTokenizer(read.readLine());
			int[] piles = new int[pileNum];
			for (int p = 0; p < pileNum; p++) {
				piles[p] = Integer.parseInt(pileST.nextToken());
			}

			int xorSum = 0;
			for (int p : piles) {
				xorSum ^= p;
			}

			System.out.println(xorSum != 0 ? "first" : "second");
		}
	}
}
```

</JavaSection>
<PySection>

```py
for _ in range(int(input())):
	pile_num = int(input())
	sizes = [int(p) for p in input().split()]
	assert pile_num == len(sizes)

	xor_sum = 0
	for s in sizes:
		xor_sum ^= s
	
	print("first" if xor_sum != 0 else "second")
```

</PySection>
</LanguageSection>

<Optional title="What if we could add?">

In some cases, players may be allowed to add sticks as well as remove them.
Funnily enough, this doesn't change how the winning and losing states are determined,
i.e. the outcome of the game.

</Optional>

## Sprague-Grundy theorem

<Resources>
	<Resource
		source="CP Algorithms"
		title="Sprague-Grundy theorem. NIM"
		url="https://cp-algorithms.com/game_theory/sprague-grundy-nim.html"	/>
	<Resource
		source="Youtube"
		title="Sprague-Grundy-Theorem"
		url="https://www.youtube.com/watch?v=GRlGknQEOW8"
		starred
	/>
</Resources>

The [Sprague-Grundy theorem](https://en.wikipedia.org/wiki/Sprague%E2%80%93Grundy_theorem) defines "nimbers" or "grundy values" as

$$
\tag{1}
n(x) = \text{mex}\{\text{all reachable nimber values}\}
$$

Here $\text{mex}$ - minimum excludant - is the smallest non-negative integer not found in the given set.

This means that every state of the game can be assigned a nimber value. Let's take a look at a particular case of the NIM game, a game with just one pile of stones and you can only remove ** 1, 2 or 3 stones** in one move, and how the nimber values behave in practice:

![alt text](./assets/nim.png)

According to $(1)$ the nimber value is the $\text{mex}$ of the reachable nimber values, in this case it is the $\text{mex}$ of the previous $3$ values, because we can only remove 1, 2 or 3 stones in one move, so the values are computed as following:

- $n(0) = 0$
- $n(1) = \text{mex}\{0\} = 1$
- $n(2) = \text{mex}\{0, 1\} = 2$
- $n(3) = \text{mex}\{0, 1, 2\} = 3$
- $n(4) = \text{mex}\{1, 2, 3\} = 0$
- $n(5) = \text{mex}\{2, 3, 0\} = 1$
- $n(6) = \text{mex}\{3, 0, 1\} = 2$
- $n(7) = \text{mex}\{0, 1, 2\} = 3$

A nimber values equal to $0$ represents a losing state of the game; see $n(4)$ and $n(7)$.

<Spoiler title="Demonstration">
- Recall that a winning state means that in one move you can reach push the other player in a losing state. For example, $n(4)=0$ because we can't reach another losing state, like $n(0)$. Similarly $n(8) = 0$, because we can't reach $n(4)$ removing 1, 2 or 3 stones in one move.
</Spoiler>

The single-pile game was a particular case, let's try extending the theorem to multiple piles of rocks. From the previous section we know that state is a losing state if the xor-sum of the piles is $0$. We can apply the same logic with the nimber values, so the nimber value of the game is equal to the xor-sum of individual games - piles- and if it's $0$, then it means the state of the game is a losing state. Mathematically this would be written as:

$$
\tag{2}
n(\sum{p_i})=\oplus n(p_i)
$$

###

### Applications

#### Snim

<FocusProblem problem="snim" />

This problem is a direct application of $(2)$. Compute the nimber values for single piles and combine them using xor-sum.

<LanguageSection>
<CPPSection>

```cpp
#include <algorithm>
#include <iostream>
#include <vector>

using namespace std;

bool solve(const vector<int> &v, const vector<int> &vals) {
	vector<int> nimber(*max_element(v.begin(), v.end()) + 1);
	for (int i = 0; i < (int)nimber.size(); i++) {
		vector<bool> seen(i + 1, false);
		for (int val : vals) {
			if (i >= val) { seen[nimber[i - val]] = true; }
		}
		int cnt = 0;
		while (seen[cnt]) { cnt++; }
		nimber[i] = cnt;
	}
	int s = 0;
	for (int x : v) { s ^= nimber[x]; }
	return s == 0;
}

int main() {
	int k;
	cin >> k;
	vector<int> a(k);
	for (int &val : a) { cin >> val; }
	int t;
	cin >> t;
	while (t--) {
		int n;
		cin >> n;
		vector<int> v(n);
		for (int &val : v) { cin >> val; }
		cout << (solve(v, a) ? 'L' : 'W');
	}
	return 0;
}
```

</CPPSection>
</LanguageSection>

#### Strange Nim

<FocusProblem problem="strange-nim" />

We can apply the Sprague-Grundy theorem $(2)$. Let $g(n,k)$ be the nimber value for a particular pile. To speed up the algorithm, a few observations are necessary:
1. $g(n, k) = n/k \iff k \mid n$
2. $g(n, k) = g(n - \lfloor n/k \rfloor - 1, k)$

<Info title="Pattern in nimber values">
When dealing with bigger values, it may be helpful to look after certain patterns in the nimber values table of the game. This way you can speed up the algorithm and not compute every time the $\text{mex}$ function. The pattern could be periodicity or a specific relation, which is the case in this problem.
</Info>

<LanguageSection>
<CPPSection>

```cpp
#include <iostream>

using namespace std;

int nimber(int n, int k) {
	if (n % k == 0) { return n / k; }
	int d = n / k + 1;
	return nimber(n - (n % k + d - 1) / d * d, k);
}

int main() {
	int t, s = 0;
	cin >> t;
	for (int i = 0; i < t; i++) {
		int n, k;
		cin >> n >> k;
		s ^= nimber(n, k);
	}
	cout << (s ? "Takahashi" : "Aoki") << '\n';
	return 0;
}
```

</CPPSection>
</LanguageSection>

### Chessboard Game, Again!

<FocusProblem problem="chessboard-games" />

We can apply the Sprague-Grundy theorem $(2)$. In this case, the nimber values will be computed recursively. The grundy value of the game is the xor-sum of the grundy values of particular
games - a chessboard with a single coin. The reachable states from $(x, y)$ are:
- $(x-2,y+1)$
- $(x-2,y-1)$
- $(x+1,y-2)$
- $(x-1,y-2)$
Thereby the nimber value of a state is the $\text{mex}$ of the above state's nimber values.

<LanguageSection>
<CPPSection>

```cpp
#include <functional>
#include <iostream>
#include <map>
#include <set>

using namespace std;

void test_case() {
	int n;
	cin >> n;
	map<pair<int, int>, int> memo;
	function<int(int, int)> nimber = [&](int x, int y) -> int {
		if (x < 1 || y < 1 || x > 15 || y > 15) { return -1; }
		if (memo.count({x, y})) { return memo[{x, y}]; }
		set<int> reachable;
		reachable.insert(nimber(x - 1, y - 2));
		reachable.insert(nimber(x + 1, y - 2));
		reachable.insert(nimber(x - 2, y + 1));
		reachable.insert(nimber(x - 2, y - 1));
		int cnt = 0;
		while (reachable.count(cnt)) { cnt++; }
		memo[{x, y}] = cnt;
		return cnt;
	};
	int s = 0;
	for (int i = 0; i < n; i++) {
		int x, y;
		cin >> x >> y;
		s ^= nimber(x, y);
	}
	cout << (s ? "First" : "Second") << '\n';
}

int main() {
	int t;
	cin >> t;
	while (t--) { test_case(); }
	return 0;
}
```

</CPPSection>
</LanguageSection>

## Problems

<Problems problems="general" />
