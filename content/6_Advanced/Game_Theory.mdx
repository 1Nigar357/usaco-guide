---
id: game-theory
title: 'Game Theory'
author: Benjamin Qi, Mihnea Brebenel
contributors: Salma J
description: 'Solving games that are usually two-player to find the winner.'
frequency: 0
---

<Resources>
    <Resource
    	source="TopCoder"
    	title="Algorithm Games"
    	url="https://www.topcoder.com/community/data-science/data-science-tutorials/algorithm-games/"
    	starred
    />
    <Resource
    	source="John H. Conway"
    	title="On Algorithms and Games"
    	url="https://sites.math.rutgers.edu/~zeilberg/EM13/onag1.pdf"
    	starred
    />
    <Resource
    	source="E. R. Berlekamp"
    	title="Winning Ways for Your Mathematical Plays"
    	url="https://bobson.ludost.net/copycrime/Winning%20Ways%202nd%20Edition/Winning.Ways.for.Your.Mathematical.Plays.V3--1568811438.pdf"
    	starred
    />
    <Resource
    	source="CP-algorithms"
    	title="Games on Graphs"
    	url="https://cp-algorithms.com/game_theory/games_on_graphs.html"
    />
    <Resource
    	source="CP-algorithms"
    	title="Sprague-Grundy Theorem & Nim"
    	url="https://cp-algorithms.com/game_theory/sprague-grundy-nim.html"
    />
</Resources>

## NIM Game

<ProblemFocus problem="nim" />

### Game description

The most well-known impartial game is the NIM game. In this game there are considered $n$ piles with stones. At every step, a player removes a non-zero number of stone from a pile. 
The game continues while there are stones left. The winner is the player that makes the last move.

Let's denote a state of the game as ${x_1, x_2, x_3, \ldots, x_n}$, where $x_i$ is the number of stones left in pile $i$. Then the winning strategy is as following:
$$
\text{The current player has a winning strategy if and only if the xor0sum of the pile sizes is not } 0
$$

The xor sum is $x_1 \oplus x_2 \oplus x_3 \ldots \oplus x_n$, where $\oplus$ denotes the [bitwise exclusive xor](/adv/xor-basis).

### Demonstration

To demonstrate this theory we have to show that from a state with xor-sum $0$ (losing), whatever the move is, we can only reach a state with non-zero xox-sum (winning), and from a winning state we can reach a losing state.

We will assume that from a state with sum-xor $0$ we can also reach another state with xor-sum $0$. Let's pick an arbitrary pile with $y$ stones and we would like to remove $x$ stones ($x \in [1, y]$). 
Denote $s$ as the xor-sum of the other $n-1$ piles, then we have $s \oplus y = 0 \iff s = y$. By removing $x$ stones from the pile, to reach a zero xor-sum state, means that $s \oplus (y - x) = 0 \iff s = y - x$. We demonstrated that $s = y$ so $s = y - x \iff y = y - x \iff x = 0$ which is false, because we can't remove $0$ stones i.e $x \in [1,y]$. 

It remains to demonstrate that from a winning state we can bring the other player in a losing state. Let $s$ be the xor-sum of all the pile sizes. If there is a pile with $y$ stone such that $y \gt y \oplus s$, then we can remove $y - y \oplus s$ stones from this pile, remaining $y - (y - y \oplus s) = y \oplus s$. Now the pile has $y \oplus s$ stones and the new xor-sum is obtained by removing $y$ and adding $y \oplus s$ i.e. $s \oplus y \oplus y \oplus s = 0$. Consequently, if there is such a pile with the property previously mentioned we can reach a losing state from a winning state. But are we guaranteed that there is always such a pile? Let $p$ be position of the most significant bit in $s$, then there should be at least one pile $x_i$ that has the bit flipped on at position $p$. The two $1$ bits cancel each other, because $1 \oplus 1 = 0$ (1). Thereby there always exists a pile satisfying: $y > y \oplus s$ i.

$$
\begin{array}{c}	\tag{1}	
	y &\quad 	b_m \ldots b_{p+1} \text{ 1 }b_{p-1} \ldots b_0 \\
	s &\quad  	0\ldots\ldots 0 \;\; \text{ 1 } c_{p-1} \ldots c_0 \\
	y \oplus s &\quad  b_m \ldots b_{p+1} \text{ 0 } d_{p-1} \ldots d_0
\end{array}
$$

<LanguageSection>
<CPPSection>

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() { 
	int t;
	cin >> t;
	while(t--) {
		int n, s = 0;
		cin >> n;
		for(int i = 0; i < n; i++) {
			int x;
			cin >> x;
			s ^= x;
		}
		cout << (s == 0 ? "second" : "first") << '\n';
	}
	return 0;
}
```

</CPPSection>
</LanguageSection>

## Sprague-Grundy theorem

<Resources>
	<Resource
		source="CP Algorithms"
		title="Sprague-Grundy theorem. NIM"
		url="https://cp-algorithms.com/game_theory/sprague-grundy-nim.html"	/>
	<Resource
		source="Youtube"
		title="Sprague-Grundy-Theorem"
		url="https://www.youtube.com/watch?v=GRlGknQEOW8"
		starred
	/>
</Resources>

The [Sprague-Grundy theorem](https://en.wikipedia.org/wiki/Sprague%E2%80%93Grundy_theorem) defines nimber (or grundy) values as:

$$
\tag{1}
n(x) = \text{mex}\{\text{all reachable nimber values}\}
$$

Here $\text{mex}$ - minimum excludant - is the smallest non-negative integer not found in the given set. 

This means that every state of the game can be assigned a nimber value. Let's take a look at a particular case of the NIM game, a game with just one pile of stones and you can only remove ** 1, 2 or 3 stones** in one move, and how the nimber values behave in practice:

![alt text](./assets/nim.png)

According to $(1)$ the nimber value is the $\text{mex}$ of the reachable nimber values, in this case it is the $\text{mex}$ of the previous $3$ values, because we can only remove 1, 2 or 3 stones in one move, so the values are computed as following:

- $n(0) = 0$
- $n(1) = \text{mex}\{0\} = 1$
- $n(2) = \text{mex}\{0, 1\} = 2$
- $n(3) = \text{mex}\{0, 1, 2\} = 3$
- $n(4) = \text{mex}\{1, 2, 3\} = 0$
- $n(5) = \text{mex}\{2, 3, 0\} = 1$
- $n(6) = \text{mex}\{3, 0, 1\} = 2$
- $n(7) = \text{mex}\{0, 1, 2\} = 3$

A nimber values equal to $0$ represents a losing state of the game; see $n(4)$ and $n(7)$.

<Spoiler title="Demonstration">
- Recall that a winning state means that in one move you can reach push the other player in a losing state. For example, $n(4)=0$ because we can't reach another losing state, like $n(0)$. Similarly $n(8) = 0$, because we can't reach $n(4)$ removing 1, 2 or 3 stones in one move. 
</Spoiler>

The single-pile game was a particular case, let's try extending the theorem to multiple piles of rocks. From the previous section we know that state is a losing state if the xor-sum of the piles is $0$. We can apply the same logic with the nimber values, so the nimber value of the game is equal to the xor-sum of individual games - piles- and if it's $0$, then it means the state of the game is a losing state. Mathematically this would be written as:

$$
\tag{2}
n(\sum{p_i})=\oplus n(p_i)
$$

###

### Applications

#### Snim 

<ProblemFocus problem="snim" />

This problem is a direct application of $(2)$. Compute the nimber values for single piles and combine them using xor-sum.

<LanguageSection>
<CPPSection>

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

bool solve(const vector<int> &v, const vector<int> &vals) {
	vector<int> nimber(*max_element(v.begin(), v.end()) + 1);
	for(int i = 0; i < (int)nimber.size(); i++) {
		vector<bool> seen(i+1, false);
		for(int val : vals) {
			if(i >= val) {
				seen[nimber[i - val]] = true;
			}
		}
		int cnt = 0;
		while(seen[cnt]) {
			cnt++;
		}
		nimber[i] = cnt;
	}
	int s = 0;
	for(int x : v) {
		s ^= nimber[x];
	}
	return s == 0;
}

int main() { 
	int k;
	cin >> k;
	vector<int> a(k);
	for(int &val : a) {
		cin >> val;
	}
	int t;
	cin >> t;
	while(t--) {
		int n;
		cin >> n;
		vector<int> v(n);
		for(int &val : v) {
			cin >> val;
		}
		cout << (solve(v, a) ? 'L' : 'W');
	}
	return 0;
}

```

</CPPSection>
</LanguageSection>

#### Strange Nim

<FocusProblem problem="strange-nim" />

We can apply the Sprague-Grundy theorem $(2)$. Let $g(n,k)$ be the nimber value for a particular pile. To speed up the algorithm, a few observations are necessary:
1. $g(n, k) = n/k \iff k \mid n$ 
2. $g(n, k) = g(n - \lfloor n/k \rfloor - 1, k)$

<Info title="Pattern in nimber values">
When dealing with bigger values, it may be helpful to look after certain patterns in the nimber values table of the game. This way you can speed up the algorithm and not compute every time the $\text{mex}$ function. The pattern could be periodicity or a specific relation, which is the case in this problem.
</Info>

<LanguageSection>
<CPPSection>

```cpp
#include <iostream>

using namespace std;

int nimber(int n, int k) {
	if(n % k == 0) {
		return n / k;
	}
	int d = n / k + 1;
	return nimber(n - (n % k + d - 1) / d * d, k);
}

int main() { 
	int t, s = 0;
	cin >> t;
	for(int i = 0; i < t; i++) {
		int n, k;
		cin >> n >> k;
		s ^= nimber(n, k);
	}
	cout << (s ? "Takahashi" : "Aoki") << '\n';
	return 0;
}

```

</CPPSection>
</LanguageSection>

## Problems

<Problems problems="general" />
