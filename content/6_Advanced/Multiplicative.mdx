---
id: multiplicative
title: 'Prefix Sums of Multiplicative Functions'
author: Tianqin Meng,  Benjamin Qi
description: This module delves into the topic of prefix sum with multiplicative functions.
frequency: 0
---

## Initial Overview

### Definition

1. If a function $f: \mathbb{Z}^+ \rightarrow \mathbb{C}$ maps positive integers to complex numbers, it's an arithmetic function.
2. If $f(n)$ is an arithmetic function, $f(1) = 1$ and f(p⋅q) = $f(p) \cdot f(q)$ for any coprime positive integers p,q, it's a multiplicative function.
3. If $f(n)$ is multiplicative and $f(p \cdot q)$ = $f(p)\cdot f(q)$ for any positive integers p,q, it's a completely multiplicative function.

If $f(n)$ is a multiplicative function, then for a positive integer $n = \prod_{i=1}^{k} p_i^{k_i}$, we have
$$
f(n) = \prod_{i=1}^{k} f(p_i^{k_i})
$$
If $f(n)$ is a completely multiplicative function, then for a positive integer $n = \prod_{i=1}^{k} p_i^{k_i}$, we have
$$
f(n) = \prod_{i=1}^{k} f(p_i)^{k_i}
$$

### Examples

Common multiplicative functions are
- Divisor function: $\sigma_k(n) = \sum_{d|n} d^k$, representing the sum of the $k$th powers of divisors of $n$. Note that $\sigma_k(n)$ and $σ^k(n)$ are different.
- Divisor count function: $\tau(n) = \sigma_0(n) = \sum_{d|n} 1$, representing the count of divisors of $n$, also denoted as $d(n)$.
- Divisor sum function: $\sigma(n) = \sigma_1(n) = \sum_{d|n} d$, representing the sum of divisors of $n$.
- Euler's totient function: $\varphi(n) = \sum_{i=1}^n [(n,i)=1] \cdot 1$, representing the count of positive integers less than or equal to $n$ and coprime to $n$. Additionally, $\sum_{i=1}^n [(n,i)=1] \cdot i = $ $$\frac{n\varphi(n) + [n=1]}{2}$$, $\varphi(n)$ is even.
- Möbius function: $\mu(n)$, serving as the multiplicative inverse of the identity function in Dirichlet convolution, $\mu(1) = 1$, for a square-free number $n = \prod_{i=1}^t p_i$, $\mu(n) = (-1)^t$, and for a number with square factors, $\mu(n) = 0$.
- Unit function: $e(n) = [n=1]$, serving as the identity element in Dirichlet convolution, completely multiplicative.
- Constant function: $I(n) = 1$, completely multiplicative.
- Identity function: $id(n) = n$, completely multiplicative.
- Power function: $id^k(n) = n^k$, completely multiplicative.

The two classic formulas regarding the Möbius function and the Euler function are:
- $$[n=1] = \sum_{d|n} \mu(d)$$, Interpreting $\mu(d)$ as the coefficients of the inclusion-exclusion principle proves it.
- $$ n = \sum_{d|n} \varphi(d) $$. To prove it, we can count the number of occurrences of $$\frac{1}{n}(1 \leq i \leq n$$) in its simplest fraction form.

### Dirichlet Convolution

The Dirichlet convolution of number-theoretic functions $f$ and $g$ is defined as $(f*g)(n) = \sum_{d|n} f(d) \cdot g(\frac{n}{d})$. Dirichlet convolution satisfies commutativity, associativity, and distributivity with respect to addition. There exists an identity function $e(n) = [n=1]$ such that $f*e = f = e*f$。If $f$ and $g$ are multiplicative functions, then $f*g$ is also multiplicative.

A common technique with Dirichlet convolution involves dealing with the convolution of a multiplicative function $f$ and the identity function $I$. For example, if $n = \prod_{i=1}^{t} p_i^{k_i}$ and $g(n) = \sum_{d|n} f(d)$，then we have
$$
g(n) = \prod_{i=1}^{t} \sum_{j=0}^{k_i} f(p_i^j)
$$

### Möbius Inversion

Möbius inversion is also a discussion regarding $g(n) = \sum_{d|n} f(d)$ , but it does not require $f$ to be multiplicative and is applicable in cases where $g(n)$ is known and $f(n)$ is to be determined.

Since $I \cdot \mu = e$， $g \cdot \mu = f \cdot I \cdot \mu = f \cdot e = f$，and $f(n) = \sum_{d|n} g(d) \cdot \mu\left(\frac{n}{d}\right)$.
Similarly,  $g(n) = \sum_{n|d} f(d) \rightarrow f(n) = \sum_{n|d} g(d) \cdot \mu\left(\frac{d}{n}\right)$，

Binomial inversion is also a similar technique. An example illustrates the relationship between the Euler function and the Möbius function: since $\sum_{d|n} \varphi(d) = n$，then $\varphi(n) = \sum_{d|n} \mu(d) \cdot \frac{n}{d}$，which implies $\frac{\varphi(n)}{n} = \sum_{d|n} \frac{\mu(d)}{d}$

## Example - Sum of Divisors

<FocusProblem problem="f1" />

### Explanation

It's not feasible to compute directly, but we can derive it as follows:

$$
\sum_{i=1}^{n}\sigma(i)=\sum_{i=1}^{n}\sum_{j=1}^{n}[j|i]\cdot j=\sum_{i=1}^{n}i\cdot\sum_{j=1}^{n}[i|j]=\sum_{i=1}^{n}i\cdot\left\lfloor\frac{n}{i}\right\rfloor
$$

When $i \leq \sqrt{n}$, there are only $O(\sqrt{n})$ distinct values for $\left\lfloor\frac{n}{i}\right\rfloor$. Similarly, when $i > \sqrt{n}$, $\left\lfloor\frac{n}{i}\right\rfloor < n$ has only $O(\sqrt{n})$ distinct values. For a fixed $\left\lfloor\frac{n}{i}\right\rfloor$, the values of $i$ form a contiguous interval, which is $\left[\left\lfloor\frac{n}{\left\lfloor\frac{n}{i}\right\rfloor+1}\right\rfloor+1,\left\lfloor\frac{n}{\left\lfloor\frac{n}{i}\right\rfloor}\right\rfloor\right]$. Therefore, the calculation can be done in $O(\sqrt{n})$ time.

Similarly, the sum of the number of divisors for the first $n$ positive integers can be calculated in the same manner. I leave this as an exercise for the reader.

Another thing to note is that $\sum_{i=1}^{n}\left\lfloor\frac{n}{i}\right\rfloor\cdot i=\sum_{i=1}^{n}\left\lfloor\frac{n}{i}\right\rfloor\cdot\frac{(\left\lfloor\frac{n}{i}\right\rfloor+1)}{2}$. This is also a common representation form.

### Implementation

**Time Complexity: $\mathcal{O}(\sqrt{n})$**

<LanguageSection>
<CPPSection>

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
using namespace std;

int main() {
    long long n, i, a, b;
    long long sum;

    scanf("%lld", &n); // Taking input for n
    sum = 0;
    for (i = 1; i * i <= n; i++) { // Looping until i * i <= n
        sum += i * (n / i); // Adding i * (n / i) to the sum
        b = n / i;
        a = n / (i + 1) + 1;
        sum += (a + b) * (b - a + 1) / 2 * i; // Adding the sum of elements from 'a' to 'b'
    }
    i--; // Decrementing i to match the last value used in the loop
    if (i == n / i) {
        sum -= i * (n / i); // Adjusting the sum if n is a perfect square
    }
    printf("%lld\n", sum); // Printing the sum
}
```

</CPPSection>
</LanguageSection>

## Example - Totient Sum

<FocusProblem problem="f2" />

### Explanation

Currently, the formulas related to Euler's totient function mentioned in this article are limited. Can we use them to simplify the problem? The answer is yes, and now we'll utilize the formula $\sum_{d|n}\varphi(d)=n$ to simplify the expression.

This formula can also be seen as $\varphi(n)=n-\sum_{d|n, d<n}\varphi(d)$. Let's denote $\phi(n)=\sum_{i=1}^n \varphi(i)$, then we have:

$$
\phi(n)=\sum_{i=1}^n\varphi(i)=\sum_{i=1}^n i−\sum_{d|i,d<i}\varphi(d)=\frac{n\cdot(n+1)}{2}−\sum_{i=2}^n\sum_{d|i,d<i}\varphi(d)=\frac{n\cdot(n+1)}{2}−\sum_{i=2}^{n}\sum_{d=1}^{\left\lfloor\frac{n}{\left(\frac{i}{d}\right)}\right\rfloor}\varphi(d)
$$

$$
n \cdot \frac{(n+1)}{2} - \sum_{i=2}^{n} \sum_{d=1}^{\lfloor \frac{n}{i} \rfloor} \phi(d) = n \cdot \frac{(n+1)}{2} - \sum_{i=2}^{n} \phi(\lfloor \frac{n}{i} \rfloor)
$$

So as long as you calculate the values of $\phi(\lfloor \frac{n}{i} \rfloor$ for $O(\sqrt{n})$ times, you can compute $\phi(n)$. What about the complexity of such an operation?

Suppose the complexity of calculating $\phi(n)$ is $T(n)$, then we have $T(n) = O(\sqrt{n}) + \sum_{i=1}^{\sqrt{n}} T(i) + T(n/i)$. **Here, we only expand one layer because deeper complexities are higher-order terms**.
So, we have $T(n) = \sum_{i=1}^{\sqrt{n}} O(\sqrt{i}) + O(\sqrt{\frac{n}{i}}) = O(n^{3/4})$.

Since $\phi(n)$ is a prefix sum of a multiplicative function, the sieve method can preprocess a portion. Assuming the preprocessing includes the first $k$ positive integers' $\phi(n)$ where $k \geq \sqrt{n}$, the complexity becomes $T(n) = \sum_{i=1}^{k} {\sqrt{\frac{n}{i}}} = O({\frac{n}{\sqrt{k}}})$. When $k = O(n^{2/3})$, we can achieve a good complexity of $T(n) = O(n^{2/3})$.

How did we come up with the place where we utilized $\varphi(n) = n-\sum_{d|n,d<n} \varphi(d)$? Let's take a look at this:

$$
\frac{n \cdot (n+1)}{2} = \sum_{i=1}^{n} i = \sum_{i=1}^{n} \sum_{d} [d|i]\varphi(d) = \sum_{i=2}^{n} \sum_{d=1}^{\left\lfloor \frac{n}{\left(\frac{i}{d}\right)} \right\rfloor} \varphi(d) = \sum_{i=1}^{n} \phi(\left\lfloor \frac{n}{i} \right\rfloor)
$$

**If we can construct a function through Dirichlet convolution that computes prefix sums more efficiently and if another function suitable for convolution is also easy to calculate, we can simplify the calculation process.** For example, in the above problem, we used the property of $\varphi * I = id$. But remember, not all problems of this type can be easily solved by just pairing with an identity function $I$. Sometimes, a more careful observation is needed.

### Implementation

**Time Complexity: $\mathcal{O}(n^{3/4})$**

<LanguageSection>
<CPPSection>

```cpp
template <int SZ> struct Sieve {
	vi pr;
	int sp[SZ], phi[SZ];  // smallest prime that divides
	Sieve() {             // above is faster
		memset(sp, 0, sizeof sp);
		phi[1] = 1;
		FOR(i, 2, SZ) {
			if (sp[i] == 0) {
				sp[i] = i, pr.pb(i);
				phi[i] = i - 1;
			}
			trav(p, pr) {
				if (p > sp[i] || i * p >= SZ) break;
				sp[i * p] = p;
				phi[i * p] = (p == sp[i] ? p : p - 1) * phi[i];
			}
		}
	}
};

const int HI = 5000000;
Sieve<HI> S;
ll N;
vmi small(HI), big;

int main() {
	setIO();
	re(N);
	big.rsz(N / HI + 2);
	FOR(i, 1, HI) small[i] = small[i - 1] + S.phi[i];
	ROF(i, 1, sz(big)) {
		ll mx = N / i;
		big[i] = mi(mx) * (mx + 1) / 2;  // dbg("HUH",i,big[i]);
		for (ll fac = 2, nex; fac <= mx; fac = nex) {
			ll quo = mx / fac;
			nex = mx / quo + 1;
			big[i] -= (nex - fac) * (quo < HI ? small[quo] : big[i * fac]);
		}
	}
	ps(big[1]);
}
```

</CPPSection>
</LanguageSection>

## Example - Enumerate Primes

<FocusProblem problem="f3" />

### Explanation

Remember the old $\mathcal{O}(N \log N)$ Eratosthenes' sieve [here](https://usaco.guide/gold/divisibility?lang=cpp#solution---counting-divisors)?

To solve this problem, we have to improve the complexity of the sieve to $\mathcal{O}(N)$.
Check out [this CF blog entry](https://codeforces.com/blog/entry/54090) for further information.

<LanguageSection>
<CPPSection>

```cpp
void get_prime(int n) {
    // 'st' is a boolean array used to mark numbers as composite
	for (int i = 2; i <= n; i++) {
        // If 'st[i]' is false, then 'i' is a prime number
		if (!st[i]) primes[++cnt] = i;
        // Mark multiples of primes as composite
		for (int j = 1; primes[j] <= n / i; j++) {
            // Mark 'i * primes[j]' as composite
			st[i * primes[j]] = true;
            // If 'i' is divisible by 'primes[j]', break the loop
			if (i % primes[j] == 0) break;
		}
	}
}

```

</CPPSection>
</LanguageSection>

This problem requires finding the count of prime numbers not exceeding $N$ and then calculating the sum of primes based on specific conditions.

1. We first run our sieve to get all the prime numbers not exceeding $N$.
2. Input and Initialization: The program reads input values N, A, and B, and initializes arrays to store prime numbers (p) and their count (pc).
3. Counting and Summing Primes: After sieving for prime numbers up to N, the program calculates the count of terms (x) in the sum $\sum_{i} p_{Ai+B}$ that do not exceed N. It does this by considering the quotient of the total count of prime numbers divided by A, adjusting for the remainder.
4. Output: The program prints the count of prime numbers (pc) and the count of terms in the sum (x). Then, it outputs the prime numbers contributing to the sum, starting from index B and skipping A elements each time.

## Implementation

**Time Complexity: $\mathcal{O}(n)$**

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 5e8;
const int M = 4e7;

int p[M];
int pc;

void sieve(int n) {
	if (n < 2) { return; }
	vector<bool> np(n + 1);
	p[pc++] = 2;
	int i;
	for (i = 3; 1ll * i * i <= n; i += 2) {
		if (!np[i]) {
			p[pc++] = i;
			for (int j = i * i; j <= n; j += i) np[j] = 1;
		}
	}
	for (; i <= n; i += 2) {
		if (!np[i]) p[pc++] = i;
	}
}

int main() {
	int n, a, b, x;
	vector<int> ans;
	cin >> n >> a >> b;
	sieve(n);
	x = pc / a + (pc % a > b);
	cout << pc << ' ' << x << '\n';
	for (int i = b; i < pc; i += a) cout << p[i] << " \n"[i + a >= pc];
}
```

</CPPSection>
</LanguageSection>

## Example - Counting Primes

<FocusProblem problem="f4" />

## Explanation

The function `prime_count` takes an integer N as input and returns the count of prime numbers not greater than N.
The algorithm employed here is a combination of prime counting methods, including the Sieve of Eratosthenes and Euler's totient function.

Here's a breakdown of the algorithm:
1. The variable y is calculated as the integer part of the cube root of N raised to the power of 1. This heuristic value helps in partitioning the range of numbers up to N.
2. We initialize an array spf (smallest prime factor) to keep track of the smallest prime factor of each number up to z. We also initialize a vector pr to store prime numbers.
3. We iterate over numbers from 2 to z, checking if the current number is prime. If it is, we update spf and add it to the pr vector.
4. We then iterate over prime numbers in the pr vector to count the primes less than or equal to N using the principle of inclusion-exclusion.
5. Finally, we calculate Euler's totient function using a recursive approach, considering prime factorization.

### Implementation

**Time Complexity: $\mathcal{O}(n^{2/3})$**

<LanguageSection>
<CPPSection>

```cpp
// https://codeforces.com/blog/entry/91632
#include<bits/stdc++.h>
using namespace std;

// O(N^{2/3})
// return π(x) = the number of prime numbers between 2 and N
long long counting_primes(const long long N) {
    if (N <= 1) return 0;
	if (N == 2) return 1;
	const int v = sqrtl(N);
	int s = (v + 1) / 2;

    vector<int> small(s);
	for (int i = 1; i < s; i++) small[i] = i;
	vector<int> rough(s);
	for (int i = 0; i < s; i++) rough[i] = 2 * i + 1;
	vector<long long> large(s);
	for (int i = 0; i < s; i++) large[i] = (N / (2 * i + 1) - 1) / 2;
	vector<bool> skip(v + 1);

    int pc = 0;
	for (int p = 3; p <= v; p += 2) if (!skip[p]) {
		int q = p * p;
		if ((long long)q * q > N) break;
		skip[p] = true;
		for (int i = q; i <= v; i += 2 * p) skip[i] = true;
		int ns = 0;
		for (int k = 0; k < s; k++) {
			int i = rough[k];
			if (skip[i]) continue;
			long long d = (long long)i * p;
			large[ns] = large[k] - (d <= v ? large[small[d >> 1] - pc] : small[(N/d-1)>>1]) + pc;
			rough[ns++] = i;
		}
		s = ns;
		for (int i = ((v-1)>>1), j = ((v / p) - 1) | 1; j >= p; j -= 2) {
			int c = small[j >> 1] - pc;
			for (int e = (j * p) >> 1; i >= e; i--) small[i] -= c;
		}
		pc++;
	}

    large[0] += (long long)(s + 2 * (pc - 1)) * (s - 1) / 2;
	for (int k = 1; k < s; k++) large[0] -= large[k];
	for (int l = 1; l < s; l++) {
		long long q = rough[l];
		long long M = N / q;
		int e = small[(M/q-1)>>1] - pc;
		if (e < l + 1) break;
		long long t = 0;
		for (int k = l + 1; k <= e; k++)
			t += small[(M/rough[k]-1)>>1];
		large[0] += t - (long long)(e - l) * (pc + l - 1);
	}

	return large[0] + 1;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    long long n;
    cin >> n;
    cout << counting_primes(n) << endl;
    return 0;
}
```
</CPPSection>
</LanguageSection>

## Problems

<Problems problems="general" />
