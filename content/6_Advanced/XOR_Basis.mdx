---
id: xor-basis
title: 'XOR Basis'
author: Benjamin Qi
frequency: 1
---

## Resources

<Resources>
	<Resource
		source="CF"
		url="https://codeforces.com/blog/entry/68953"
		title="DrSwad - Technique for Some XOR Related Problems"
		starred
	>
		inspiration for below
	</Resource>
	<Resource
		source="Benq"
		url="https://drive.google.com/drive/folders/1Ll8EuA3p64JLmzImfQu5qiWvc6_QTa0E?usp=sharing"
		title="XOR Presentation"
		starred
	>
		used at USACO Camp
	</Resource>
	<Resource
		source="hackmd"
		url="https://hackmd.io/@minhnguyent546/BJKcH_2ti#XOR-BASIS"
		title="Minh Thien Nguyen - XOR BASIS"
		starred
	>
		detailed explanation about XOR basis note: translate the page to english
	</Resource>
</Resources>

<FocusProblem problem="xorqueries" />

You are given a tree consisting of $n$ vertices. There is an integer written on each vertex; the $i$-th vertex has integer $$a_i$$ written on it. You have to process $q$ queries. The $i$-th query consists of three integers $$x_i$$, $$y_i$$ and $$k_i$$. For this query, you have to answer if it is possible to choose a set of vertices $v_1,v_2,â€¦,v_m$ (possibly empty) such that:
- every vertex $$v_j$$ is on the simple path between $$x_i$$ and $$y_i$$ (endpoints can be used as well);
- $$a_{v_1} \oplus a_{v_2} \oplus \dots \oplus a_{v_m} = k_i$$, where $\oplus$ denotes the bitwise XOR operator.

## Solution - Trees and XOR Queries Again

<!-- [Official Tutorial](https://codeforces.com/blog/entry/122951) -->

To efficiently compute XOR bases on paths in a tree, we use a method involving tree rooting, **Lowest Common Ancestor (LCA)**, and properties of **XOR bases**. The process begins by rooting the tree and using LCA to split any path into two vertical paths. For each vertex $$v$$, we maintain a list of "interesting" vertices that significantly influence the XOR base when traversing from $$v$$ to the root. Due to the properties of XOR bases, these lists are small, with a maximum size of 20.

The core idea is to build these lists for all vertices efficiently. For a vertex $$v$$, its list is derived from its parent's list. If $$v$$ adds a new element to the XOR base of its parent's list, $$v$$ is added to its list; otherwise, one element in the parent's list is replaced. This propagation ensures that the size of each list remains manageable and enables efficient construction of these lists in $\mathcal{O}(nB^2)$ time, where $$B$$ is the size of the XOR base, typically 20.

When answering a query, the XOR base for any path is obtained by combining the lists from the two vertical paths derived from the LCA. This merging and computation can be done in $\mathcal{O}(B^2 + \log n)$ time per query, providing an efficient solution for the problem.

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 200005, K = 20;
vector<int> arr(N), tin(N, 0), tout(N, 0), up[N];
vector<int> adj[N];
vector<vector<int>> p(N, vector<int> (K, 0));
int T = 0;

int reduce(array<int, K> &b, int x) {
    for (int i = K - 1; i >= 0; i--) {
        if (x & (1 << i)) {
            x ^= b[i];
        }
    }
    return x;
}

bool add(array<int, K> &b, int x) {
    x = reduce(b, x);
    if (x != 0) {
        for (int i = K - 1; i >= 0; i--) {
            if (x & (1 << i)) {
                b[i] = x;
                return true;
            }
        }
    }
    return false;
}

bool check(array<int, K> &b, int x) {
    return (reduce(b, x) == 0);
}

vector<int> rebuild_path(const vector<int> &path, int v) {
    array<int, K> b {0};
    vector<int> res;
    if (add(b, arr[v])) {
        res.push_back(v);
    }
    for (auto x : path) {
        if (add(b, arr[x])) {
            res.push_back(x);
        }
    }
    return res;
}

void dfs(int v, int u) {
    tin[v] = T++;
    if (u == v) {
        up[v] = rebuild_path(vector<int>(0), v);
    } else {
        up[v] = rebuild_path(up[u], v);
    }

    p[v][0] = u;
    for (int i = 1; i < K; i++) {
        p[v][i] = p[p[v][i - 1]][i - 1];
    }

    for (int i = 0; i < (int)adj[v].size(); i++) {
        if (adj[v][i] != u) {
            dfs(adj[v][i], v);
        }
    }
    tout[v] = T++;
}

bool is_ancestor(int u, int v) {
    return (tin[u] <= tin[v] && tout[u] >= tout[v]);
}

int LCA(int x, int y) {
    if (is_ancestor(x, y)) {
        return x;
    }
    for (int i = K - 1; i >= 0; i--) {
        if (!is_ancestor(p[x][i], y)) {
            x = p[x][i];
        }
    }
    return p[x][0];
}

bool query(int x, int y, int k) {
    array<int, K> b {0};
    int lca = LCA(x, y);
    for (auto v : up[x]) {
        if (!is_ancestor(v, y)) {
            add(b, arr[v]);
        }
    } 

    for (auto v : up[y]) {
        if (!is_ancestor(v, x)) {
            add(b, arr[v]);
        }
    }

    add(b, arr[lca]);
    return check(b, k);
}

int main() {
    int n, q;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    for (int i = 0; i < n - 1; i++) {
        int u, v;
        cin >> u >> v;
        u--,v--;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    dfs(0, 0);
    cin >> q;
    for (int i = 0; i < q; i++) {
        int x, y, k;
        cin >> x >> y >> k;
        x--,y--;
        cout << (query(x, y, k) ? "YES" : "NO") << '\n';
    }

    return 0;
}
```

</CPPSection>

</LanguageSection>

## Problems

<Resources>
	<Resource
		source="Benq"
		title="XOR Problemset"
		url="https://www.hackerrank.com/contests/xor-lab/challenges"
		starred
	>
		8 related tasks
	</Resource>
</Resources>

Some harder tasks:

<Problems problems="general" />
