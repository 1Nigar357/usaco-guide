---
id: PIE
title: 'Principle of Inclusion and Exclusion'
author: Mihnea Brebenel
prerequisites:
  - combo
description:
  'The inclusion-exclusion principle is a counting technique that generalizes the formula for computing the size of union of n finite sets.'
frequency: 2
---

## Tutorial

<Resources>
    <Resource source="CP Algorithm" title="the Inclusion-Exclusion Principle" url="https://cp-algorithms.com/combinatorics/inclusion-exclusion.html" starred> Well-covered article </Resource>
    <Resource sorce="wiki" title="Inclusion-exclusion  principle" url="https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle"></Resource>
</Resources>

## Mobius Function

The [Mobius function](https://en.wikipedia.org/wiki/M%C3%B6bius_function) is a multiplicative function that comes in handy when dealing with inclusion-exclusion technique and divisors-related problems. It has values in $\{-1, 0, 1\}$  depending on number's factorization.

$$
\mu(n)=\begin{cases}
1 & \text{if $n$ is $1$},\\
0 & \text{if $n$ has a squared prime factor},\\
(-1)^k & \text{if $n$ is a product of $k$ distinct prime factors}.
\end{cases}
$$

Belowe you can see the first $20$ values of $\mu(n)$:

| n | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 |
| ---| ---|-|-  | - | - | - | - | - | - | -  | -  |  - | -  |  - | -  | -  | -  | -  | -- |
| $\mu(n)$ | 1 | -1 | -1 | 0 | -1 | 1 | -1 | 0 | 0 | 1 | -1 | 0 | -1 | 1 | 1 | 0 | -1 | 0 | -1|


## Applications

### SQFREE

<FocusProblem problem="SQRFEE" />

<LanguageSection>
<CPPSection>

```cpp 
#include <iostream>
#include <vector>

using namespace std;

const int VALMAX = 2e7;

int mobius[VALMAX];

void precompute() {
    mobius[1] = -1;
    for(int i = 1; i < VALMAX; i++) {
        if(mobius[i]) {
            mobius[i] = -mobius[i];
            for(int j = 2 * i; j < VALMAX;j += i) {
                mobius[j] += mobius[i];
            }
        }
    }
}

void test_case() {
    long long n;
    cin >> n;
    long long cnt = 0;
    for(int i = 1; 1LL * i * i <= n; i++) {
        cnt += mobius[i] * n / (1LL * i * i);
    }
    cout << cnt << '\n';
}

int main() {
    int t;
    cin >> t;
    precompute();
    while(t--) {
        test_case();
    }
    return 0;
}
```

</CPPSection>
</LanguageSection>