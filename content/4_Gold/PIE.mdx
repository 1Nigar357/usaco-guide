---
id: PIE
title: 'Principle of Inclusion and Exclusion'
author: Mihnea Brebenel
prerequisites:
  - combo
description:
  'The inclusion-exclusion principle is a counting technique that generalizes the formula for computing the size of union of n finite sets.'
frequency: 2
---

## Tutorial

<Resources>
    <Resource source="CP Algorithm" title="the Inclusion-Exclusion Principle" url="https://cp-algorithms.com/combinatorics/inclusion-exclusion.html" starred> Well-covered article </Resource>
    <Resource sorce="wiki" title="Inclusion-exclusion  principle" url="https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle"></Resource>
</Resources>

## Mobius Function

The [Mobius function](https://en.wikipedia.org/wiki/M%C3%B6bius_function) is a multiplicative function that comes in handy when dealing with inclusion-exclusion technique and divisors-related problems. It has values in $\{-1, 0, 1\}$  depending on number's factorization.

$$
\mu(n)=\begin{cases}
1 & \text{if $n$ is $1$},\\
0 & \text{if $n$ has a squared prime factor},\\
(-1)^k & \text{if $n$ is a product of $k$ distinct prime factors}.
\end{cases}
$$

Belowe you can see the first $20$ values of $\mu(n)$:

| n | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 |
| ---| ---|-|-  | - | - | - | - | - | - | -  | -  |  - | -  |  - | -  | -  | -  | -  | -- |
| $\mu(n)$ | 1 | -1 | -1 | 0 | -1 | 1 | -1 | 0 | 0 | 1 | -1 | 0 | -1 | 1 | 1 | 0 | -1 | 0 | -1|


## Applications

### SQFREE

<FocusProblem problem="SQRFEE" />

<LanguageSection>
<CPPSection>

```cpp 
#include <iostream>
#include <vector>

using namespace std;

const int VALMAX = 2e7;

int mobius[VALMAX];

void precompute() {
    mobius[1] = -1;
    for(int i = 1; i < VALMAX; i++) {
        if(mobius[i]) {
            mobius[i] = -mobius[i];
            for(int j = 2 * i; j < VALMAX;j += i) {
                mobius[j] += mobius[i];
            }
        }
    }
}

void test_case() {
    long long n;
    cin >> n;
    long long cnt = 0;
    for(int i = 1; 1LL * i * i <= n; i++) {
        cnt += mobius[i] * n / (1LL * i * i);
    }
    cout << cnt << '\n';
}

int main() {
    int t;
    cin >> t;
    precompute();
    while(t--) {
        test_case();
    }
    return 0;
}
```

</CPPSection>
</LanguageSection>

### KPRIMESB

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>

using namespace std;

int test_case(vector<int> &primes) {
    int n, k;
    cin >> n >> k;
    vector<int> v(k);
    for(int &prime : v) {
        cin >> prime;
    }
    int cnt = 0;
    for(int mask = 0; mask < (1 << k); mask++) {
        int x = 1;
        for(int i = 0; i < k && x <= n; i++) {
            if((1 << i) & mask) {
                x *= v[i];
            }
        }
        if(__builtin_popcount(mask) & 1) {
            cnt -= n / x;
        } else {
            cnt += n / x;
        }
    }
    for(int &p : v) {
        if(p <= n) {
            cnt++;
        }
    }
    cnt -= primes[n];
    return cnt;
}

vector<int> precompute() {
    const int NMAX = 2e6;
    bitset<NMAX> sieve;
    vector<int> primes(NMAX, 0);
    sieve.set();
    primes[1] = 1;
    for(int i = 2; i < NMAX; i++) {
        primes[i] = primes[i - 1];
        if(sieve[i]) {
            for(int j = 2 * i; j < NMAX; j += i) {
                sieve[j] = false;
            }
            primes[i]++;
        }
    }
    return primes;
}

int main() {
    int T;
    cin >> T;
    vector<int> primes = precompute();
    for(int t = 1; t <= T; t++) {
        cout << "Case " << t << ":" << ' ' << test_case(primes) << endl;
    }
    return 0;
}
```

</CPPSection>
</LanguageSection>