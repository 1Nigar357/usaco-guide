---
id: range-sweep
title: 'Range Queries with Sweep Line'
author: Benjamin Qi, Andi Qu, Dong Liu, Peng Bai
prerequisites:
  - PURS
  - lis
description: 'Solving 2D grid problems using 1D range queries.'
frequency: 2
---

<FocusProblem problem="sample" />

<FocusProblem problem="sample2" />


## Solution - Intersection Points

We can sweep from bottom to top (by the $y$ coordinate); storing two events for
vertical segments (one for start and one for end) and one event for horizontal
segments.

We can use a Binary Indexed Tree to store the number of **active** vertical
segments for each $x$ coordinate.

Then, every time we encounter the start of a vertical segment, we increment the
counter for $x$ in the BIT.

Similarly, we decrement the counter for $x$ every time we see the end of a
vertical segment.

When we encounter a horizontal segment, we would query the number of active
ranges in $[x_1, x_2]$ where $x_1$ is the lower $x$ coordinate and $x_2$ is the
upper $x$ coordinate of the segment.

Our answer would be the sum of all the queries.

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

// max coordinate
const int X = 1e6;
int bit[2 * X + 1];

void update(int i, int x) {
	for (; i <= 2 * X; i += i & (-i)) bit[i] += x;
}
int query(int i) {
	int sum = 0;
	for (; i > 0; i -= i & (-i)) sum += bit[i];
	return sum;
}

int n;
vector<array<int, 4>> v;

int main() {
	cin.tie(0)->sync_with_stdio(0);
	cin >> n;
	// types of events (order for if some y values are equal):
	// 1 -> start of vertical segment
	// 2 -> horizontal segment
	// 3 -> end of vertical segment
	for (int i = 0, x1, y1, x2, y2; i < n; ++i) {
		cin >> x1 >> y1 >> x2 >> y2;
		if (y1 == y2) v.push_back({y1, 2, x1, x2});
		else {
			v.push_back({y1, 1, x1, 1});
			v.push_back({y2, 3, x1, 1});
		}
	}
	sort(begin(v), end(v));

	long long ans = 0;
	for (auto [y, type, x1, x2] : v) {
		x1 += X, x2 += X;
		if (type == 1) update(x1, 1);
		else if (type == 2) ans += query(x2) - query(x1 - 1);
		else update(x1, -1);
	}
	cout << ans << '\n';
}
```

</CPPSection>

</LanguageSection>

## Solution - Springboards

**Naive DP:** $\mathcal{O}(P^2)$

The first step is to create a DP to solve the first subtask. The states are the springboards and the transitions are between springboards. First, sort the springboards by the pair $(x_1, y_1)$ in increasing order. It is possible to show that for all $i$, $j$, where $i < j$, Bessie cannot use springboard $j$ then $i$ later.

For each springboard $i$, let $\texttt{ans}[i]$ denote the minimum distance needed to walk to the start point of springboard $i$.

Let $\texttt{dist}(a, b)$ be the walking distance from the end of springboard $a$ and the start of springboard $b$.

$$$
\texttt{dist}(a, b) = x_1[b] + y_1[b] - x_2[a] - y_2[a]
$$$

Then, the transitions are:

$$$
\texttt{ans}[i] = \min\limits_{j < i, x_2[j] \le x_1[i], y_2[j] \le y_1[i]}(ans[j] + \texttt{dist}(j, i))
$$$

**Full Solution:** $\mathcal{O}(P \log P)$

Optimizing the DP involves the use of a min point update range query segment tree. Let's first expand $dist(i, j)$ in the transition formula.

$$$
\texttt{ans}[i] = \min\limits_{j < i, x_2[j] \le x_1[i], y_2[j] \le y_1[i]}(\texttt{ans}[j] + x_1[i] + y_1[i] - x_2[j] - y_2[j])
$$$
$$$
\texttt{ans}[i] = x_1[i] + y_1[i] + \min\limits_{j < i, x_2[j] \le x_1[i], y_2[j] \le y_1[i]}(\texttt{ans}[j] - x_2[j] - y_2[j])
$$$

We notice that everything inside the $\min$ statement only depends on $j$. The segment tree stores $\texttt{ans}[j] - x_2[j] - y_2[j]$ at index $y_2[j]$. We can seperate the start and end of springboards to create two seperate events for each springboard, still sorting by $(x, y)$. When the event is the start of a springboard, update $ans[i]$ through a segment tree query. When the event is the end of a springboard, update the segment tree.

By processing in order, the first two conditions in the $\min$ statement are always satisfied. The third is where the segment tree comes into play, where querying the range $[0, y_1[i]]$ is sufficent to satisfy all constraints.

Due to the large $N$, coordinate compression is required in the code.

```cpp
#include <bits/stdc++.h>
using namespace std;
template <class T> bool ckmin(T &a, const T &b) {
	return b < a ? a = b, 1 : 0;
}

/**
 * Description: 1D point update, range query where \texttt{comb} is
 * any associative operation. If $N=2^p$ then \texttt{seg[1]==query(0,N-1)}.
 * Time: O(\log N)
 * Source:
 * http://codeforces.com/blog/entry/18051
 * KACTL
 * Verification: SPOJ Fenwick
 */

template <class T> struct Seg {  // comb(ID,b) = b
	const T ID = 0;
	T comb(T a, T b) { return min(a, b); }
	int n;
	vector<T> seg;
	void init(int _n) {
		n = _n;
		seg.assign(2 * n, ID);
	}
	void pull(int p) { seg[p] = comb(seg[2 * p], seg[2 * p + 1]); }
	void upd(int p, T val) {  // set val at position p
		ckmin(seg[p += n], val);
		for (p /= 2; p; p /= 2) pull(p);
	}
	T query(int l, int r) {  // sum on interval [l, r]
		T ra = ID, rb = ID;
		for (l += n, r += n + 1; l < r; l /= 2, r /= 2) {
			if (l & 1) ra = comb(ra, seg[l++]);
			if (r & 1) rb = comb(seg[--r], rb);
		}
		return comb(ra, rb);
	}
};

const int MX = 1e5 + 5;
Seg<int> S;
int N, P;
int ans[MX];
vector<int> distinct_y;

int query_min(int ind) { return S.query(0, ind); }
void ins(int ind, int val) { S.upd(ind, val); }
// gets the coordinate compressed y
int y_index(int y) {
	return lower_bound(begin(distinct_y), end(distinct_y), y) - begin(distinct_y);
}

int main() {
	ios_base::sync_with_stdio(0); cin.tie(0);
	freopen("boards.in", "r", stdin);
	freopen("boards.out", "w", stdout);
	cin >> N >> P;
	vector<array<int, 4>> events;
	for (int i = 0; i < P; ++i) {
		int x1, y1, x2, y2;
		cin >> x1 >> y1 >> x2 >> y2;
		events.push_back({x1, y1, i, -1});  // start point
		events.push_back({x2, y2, i, 1});   // end point
		distinct_y.push_back(y1);
		distinct_y.push_back(y2);
	}

	sort(begin(distinct_y), end(distinct_y));
	sort(begin(events), end(events));
	S.init(2 * P);
	ins(0, 0);
	for (auto [x, y, i, type] : events) {
		if (type == -1) {
			ans[i] = x + y + query_min(y_index(y));
		} else {
			ins(y_index(y), ans[i] - x - y);
		}
	}
	// adds 2N to include the transition from the last springboard to the endpoint
	cout << query_min(2 * P - 1) + 2 * N; 
}
```

Bonus: Think of this problem as maximizing the distance covered by springboards to simplify the solution.

## Different Approach - Springboards
It turns out there is also a simpler though less straightforward method to solve this problem.

The problem boils down to having a data structure that supports the following
operations:

1. Add a pair $(a,b)$.
2. For any $x$, query the minimum value of $b$ over all pairs satisfying
   $a\le x$.

This solution is described in the [official editorial](https://usaco.org/current/data/sol_boards_gold_jan20.html) and the [other module](/adv/springboards).
## Problems

<Problems problems="sweep" />

Relating to LIS:

<Problems problems="numLIS" />
