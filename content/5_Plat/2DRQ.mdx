---
id: 2DRQ
title: '2D Range Queries'
author: Benjamin Qi, Andi Qu
contributors: Daniel Zhu
prerequisites:
  - sparse-segtree
description: 'Extending Range Queries to 2D (and beyond).'
frequency: 1
---

## 2D RMQ

<Resources>
	<Resource source="CF" title="retrograd - Multi-Dimensional RMQ" url="53810" />
</Resources>

Quite rare, I've only needed this once.

<!-- - GP of Serbia 2020 B -->

## 2D BIT

<FocusProblem problem="bitSam" />

### Tutorial

<Resources>
	<Resource
		source="GFG"
		title="2D BIT"
		url="two-dimensional-binary-indexed-tree-or-fenwick-tree"
	/>
	<Resource
		source="TC"
		title="Binary Indexed Trees"
		url="binary-indexed-trees"
	/>
</Resources>

### Implementation

Essentially, we just nest the loops that one would find in a 1D BIT to get
N-dimensional BITs. We can then use
[PIE](https://brilliant.org/wiki/principle-of-inclusion-and-exclusion-pie/) to
query subrectangles.

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int bit[1001][1001];
int n;

void update(int x, int y, int val) {
	for (; x <= n; x += (x & (-x))) {
		for (int i = y; i <= n; i += (i & (-i))) { bit[x][i] += val; }
	}
}

int query(int x1, int y1, int x2, int y2) {
	int ans = 0;
	for (int i = x2; i; i -= (i & (-i))) {
		for (int j = y2; j; j -= (j & (-j))) { ans += bit[i][j]; }
	}
	for (int i = x2; i; i -= (i & (-i))) {
		for (int j = y1 - 1; j; j -= (j & (-j))) { ans -= bit[i][j]; }
	}
	for (int i = x1 - 1; i; i -= (i & (-i))) {
		for (int j = y2; j; j -= (j & (-j))) { ans -= bit[i][j]; }
	}
	for (int i = x1 - 1; i; i -= (i & (-i))) {
		for (int j = y1 - 1; j; j -= (j & (-j))) { ans += bit[i][j]; }
	}
	return ans;
}

int main() {
	iostream::sync_with_stdio(false);
	cin.tie(0);
	int q;
	cin >> n >> q;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++) {
			char c;
			cin >> c;
			if (c == '*') update(j, i, 1);
		}
	while (q--) {
		int t;
		cin >> t;
		if (t == 1) {
			int x, y;
			cin >> y >> x;
			if (query(x, y, x, y)) update(x, y, -1);
			else update(x, y, 1);
		} else {
			int y1, x1, y2, x2;
			cin >> y1 >> x1 >> y2 >> x2;
			cout << query(x1, y1, x2, y2) << '\n';
		}
	}
	return 0;
}
```

### Alternative Implementation

Using the multidimensional implementation mentioned
[here](/gold/PURS/#solution---dynamic-range-sum-queries-with-a-bit).

```cpp
template <class T, int... Ns> struct BIT {
	T val = 0;
	void upd(T v) { val += v; }
	T query() { return val; }
};

template <class T, int N, int... Ns> struct BIT<T, N, Ns...> {
	BIT<T, Ns...> bit[N + 1];
	template <typename... Args> void upd(int pos, Args... args) {
		for (; pos <= N; pos += (pos & -pos)) bit[pos].upd(args...);
	}
	template <typename... Args> T sum(int r, Args... args) {
		T res = 0;
		for (; r; r -= (r & -r)) res += bit[r].query(args...);
		return res;
	}
	template <typename... Args> T query(int l, int r, Args... args) {
		return sum(r, args...) - sum(l - 1, args...);
	}
};  // BIT<int,10,10> gives a 2D BIT

BIT<int, 1000, 1000> B;
int n, q;

int main() {
	setIO();
	re(n, q);
	F0R(i, n) {
		string s;
		re(s);
		F0R(j, n) if (s[j] == '*') B.upd(i + 1, j + 1, 1);
	}
	F0R(i, q) {
		int t;
		re(t);
		if (t == 1) {
			int y, x;
			re(y, x);
			if (B.query(y, y, x, x)) B.upd(y, x, -1);
			else B.upd(y, x, 1);
		} else {
			int y1, x1, y2, x2;
			re(y1, x1, y2, x2);
			ps(B.query(y1, y2, x1, x2));
		}
	}
}
```

</CPPSection>

</LanguageSection>

### Problems

<Problems problems="bit" />

<Optional title="Range Update and Range Query in Higher Dimensions">

Lazy propagation on segment trees does not extend to higher dimensions. However,
you can extend the 1D BIT solution to solve range increment range sum in higher
dimensions as well! See [this paper](https://arxiv.org/pdf/1311.6093.pdf) for
details.

{/* - USACO Camp - "Cows Play Global Thermonuclear War" (2D case) */}

</Optional>

## 2D Offline Sum Queries

See
[my implementations](<https://github.com/bqi343/USACO/tree/master/Implementations/content/data-structures/2D%20Range%20Queries%20(15.2)>).

<FocusProblem problem="offSam" />

The intended complexity is $\mathcal{O}(N\log^2 N)$ with a good constant factor.
This requires updating points and querying rectangle sums $N$ times for points
with coordinates in the range $[1,N]$. However, the 2D BITs mentioned above use
$\mathcal{O}(N^2)$ memory, which is too much.

### Solution - Soriya's Programming Project

Since we know all of the updates and queries beforehand, we can reduce the
memory usage while maintaining a decent constant factor.

We could use an unordered map instead of a 2D array, but this gives
$\mathcal{O}(N\log^2N)$ memory and time and the constant factors for both are
terrible.

A better idea is to compress the points to be updated so that you only need
$\mathcal{O}(N\log N)$ memory.

This doesn't require knowing the queries beforehand.

- [Benq's 1D offline BIT](<https://github.com/bqi343/USACO/blob/master/Implementations/content/data-structures/1D%20Range%20Queries%20(9.2)/BIToff.h>)
- [Benq's 2D offline BIT](<https://github.com/bqi343/USACO/blob/master/Implementations/content/data-structures/2D%20Range%20Queries%20(15.2)/BIT2DOff%20(15.2).h>)

Here's an implementation of the offline 2D BIT presented above that may be
easier to understand, albeit significantly slower due to a high constant factor:

<LanguageSection>
<CPPSection>

```cpp
// see code example below for usage
struct BIT2D {
	int n;
	vector<vector<int>> vals;
	vector<vector<int>> bit;

	BIT2D(int n, vector<pair<int, int>> todo) : n(n), vals(n), bit(n) {
		// sort points by y-coordinate
		sort(todo.begin(), todo.end(), [](pair<int, int> a, pair<int, int> b) {
			return a.second < b.second;
		});

		// ensures vals and bit are 1-indexed
		for (int i = 1; i <= n; i++) { vals[i].push_back(0); }
		for (const auto &[x, y] : todo) {
			for (int z = x; z <= n; z += z & -z) {
				if (vals[z].back() != y) { vals[z].push_back(y); }
			}
		}

		for (int i = 1; i <= n; i++) { bit[i].resize(vals[i].size()); }
	}

	/** adds t to the point (x, y) */
	void upd(int x, int y, int t = 1) {
		else {
			for (; x <= n; x += x & -x) {
				int z = ind(vals[x], y);
				assert(z && vals[x][z] == y);
				for (; z < bit[x].size(); z += z & -z) { bit[x][z] += t; }
			}
		}
	}

	/** @return returns sum of points in rectangle with top-right corner (x, y)
	 */
	int query(int x, int y) {
		int tot = 0;
		for (; x > 0; x -= x & -x) {
			for (int z = ind(vals[x], y); z > 0; z -= z & -z) {
				tot += bit[x][z];
			}
		}
		return tot;
	}

	/** @return sum of points with x in [x1, x2] and y in [y1, y2] */
	int query(int x1, int x2, int y1, int y2) {
		if (x1 > x2 || y1 > y2) return 0;
		else
			return (+query(x2, y2) - query(x1 - 1, y2) - query(x2, y1 - 1) +
			        query(x1 - 1, y1 - 1));
	}
};
```

</CPPSection>
</LanguageSection>

And you might use it like so:

<LanguageSection>
<CPPSection>
```cpp
```cpp
