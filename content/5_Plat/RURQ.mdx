---
id: RURQ
title: 'Range Update Range Query'
author: Benjamin Qi, Mihnea Brebenel
prerequisites:
  - PURS
description:
  Lazy updates on segment trees and two binary indexed trees in conjunction.
frequency: 1
---

## BIT Revisited

<FocusProblem problem="bitSample" />

Binary Indexed Trees can support range increments in addition to range sum
queries.

<Resources>
	<Resource
		source="GFG"
		title="Range Update Point Query"
		url="binary-indexed-tree-range-updates-point-queries/"
	 />
	<Resource
		source="GFG"
		title="Range Update Range Query"
		url="binary-indexed-tree-range-update-range-queries/"
	 />
	<Resource
		source="bmerry"
		title="Interval Trees"
		url="https://saco-evaluator.org.za/presentations/2014%20Camp%202/Interval%20Trees%20(Bruce%20Merry).pdf#page=36"
		starred
	 />
</Resources>

### Implementation

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

// BeginCodeSnip{BIT Code (from PURS module)}
template <class T> class BIT {
  private:
	int size;
	vector<T> bit;
	vector<T> arr;

  public:
	BIT(int size) : size(size), bit(size + 1), arr(size) {}

	void set(int ind, T val) { add(ind, val - arr[ind]); }

	void add(int ind, T val) {
		arr[ind] += val;
		ind++;
		for (; ind <= size; ind += ind & -ind) { bit[ind] += val; }
	}

	T pref_sum(int ind) {
		ind++;
		T total = 0;
		for (; ind > 0; ind -= ind & -ind) { total += bit[ind]; }
		return total;
	}
};
// EndCodeSnip

int main() {
	int test_num;
	cin >> test_num;
	for (int t = 0; t < test_num; t++) {
		int n, q;
		cin >> n >> q;

		BIT<long long> bit_values(n), bit_count(n);
		for (int i = 0; i < q; i++) {
			int type;
			cin >> type;

			if (type == 0) {
				int p, q, val;
				cin >> p >> q >> val;

				// Update the 2 BITs
				bit_values.add(p - 1, val);
				bit_count.add(p - 1, val * (p - 1));
				bit_values.add(q, -val);
				bit_count.add(q, -val * q);
			} else {
				int p, q;
				cin >> p >> q;
				cout << 1LL * bit_values.pref_sum(q) * q -
				            bit_count.pref_sum(q) -
				            (1LL * bit_values.pref_sum(p - 1) * (p - 1) -
				             bit_count.pref_sum(p - 1))
				     << '\n';
			}
		}
	}
}
```

</CPPSection>
</LanguageSection>

### Problems

<Problems problems="bitProb" />

## Lazy Segment Tree

<FocusProblem problem="lazySample" />

### Solution - Range Updates & Sums

This question asks you to support the following types of queries:

- Add a value to all elements within the range $[a,b]$.

- Set all values within the range $[a,b]$ to a certain value.

- Find the sum of all values in range $[a,b]$.

Consider the first two types of queries. A lazy tag will be created in each node
of the tree for each type. In this solution, $\texttt{lzAdd}$ will represent the
lazy tag for the range add query and $\texttt{lzSet}$ will represent the lazy
tag for the range set query.

Given the two different types of update queries, a total of four different
situations might take place after any update:

- Range add when $\texttt{lzSet}$ equals 0: Simply add the new value to the
  pre-existing value.

- Range add when $\texttt{lzSet}$ doesn't equal 0: Add the new value to
  $\texttt{lzSet}$ and clear $\texttt{lzAdd}$.

- Range set when $\texttt{lzAdd}$ equals 0: Simply update the $\texttt{lzSet}$
  value.

- Range set when $\texttt{lzAdd}$ doesn't equal 0: Again, simply update the
  $\texttt{lzSet}$ value since a set update will override all previous add
  updates.

Given the mechanics behind the `pushdown` function, all you need is a regular
range-sum segment tree to solve the question.

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

// T = tree node type, which will be long long
// U = update type, which will be array<ll, 2>
// Updates are: {lazy_set, lazy_add}
template <class T, class U> class LazySegtree {
  private:
	static constexpr T ID = 0;          // neutral tree node value
	static constexpr U LZ_ID = {0, 0};  // neutral lazy update value
	const int sz;
	vector<T> t;
	vector<U> lz;

	/** @return result of joining two tree nodes together */
	inline T comb(T a, T b) { return a + b; }

	/** builds the segtree nodes */
	void build(int v, int l, int r, const vector<T> &a) {
		if (l == r) {
			t[v] = a[l];
		} else {
			int m = (l + r) / 2;
			build(2 * v, l, m, a);
			build(2 * v + 1, m + 1, r, a);
			t[v] = comb(t[2 * v], t[2 * v + 1]);
		}
	}

	/** applies lazy update to t[v], places update at lz[v] */
	void apply(int v, int len, U x) {
		if (x[0] != 0) {
			t[v] = 1ll * x[0] * len;
			lz[v] = {x[0], 0};
		}
		if (x[1] != 0) {
			t[v] += 1ll * x[1] * len;
			if (lz[v][0] == 0) {
				lz[v][1] += x[1];
			} else {
				lz[v][0] += x[1];
				lz[v][1] = 0;
			}
		}
	}

	/** pushes down lazy update to children of v */
	void pushdown(int v, int l, int r) {
		if (lz[v] != LZ_ID && l != r) {
			int m = (l + r) / 2;
			apply(2 * v, m - l + 1, lz[v]);
			apply(2 * v + 1, r - m, lz[v]);
		}
		lz[v] = LZ_ID;
	}

	void range_update(int v, int tl, int tr, int ql, int qr, U x) {
		if (qr < tl || ql > tr) return;
		if (ql <= tl && tr <= qr) {
			apply(v, tr - tl + 1, x);
		} else {
			pushdown(v, tl, tr);
			int m = (tl + tr) / 2;
			range_update(2 * v, tl, m, ql, qr, x);
			range_update(2 * v + 1, m + 1, tr, ql, qr, x);
			t[v] = comb(t[2 * v], t[2 * v + 1]);
		}
	}

	T range_sum(int v, int l, int r, int ql, int qr) {
		if (qr < l || ql > r) return ID;
		if (l >= ql && r <= qr) return t[v];
		pushdown(v, l, r);
		int m = (l + r) / 2;
		return comb(range_sum(2 * v, l, m, ql, qr),
		            range_sum(2 * v + 1, m + 1, r, ql, qr));
	}

  public:
	LazySegtree(const vector<T> &a)
	    : sz((int)a.size()), t(4 * sz, ID), lz(4 * sz, LZ_ID) {
		build(1, 0, sz - 1, a);
	}

	/** updates [ql, qr] with the update x */
	void range_update(int ql, int qr, U x) {
		range_update(1, 0, sz - 1, ql, qr, x);
	}

	/** sum of array values on [ql, qr] */
	T range_sum(int ql, int qr) { return range_sum(1, 0, sz - 1, ql, qr); }
};

int main() {
	int n, q;
	cin >> n >> q;
	vector<ll> a(n);
	for (ll &i : a) { cin >> i; }

	LazySegtree<ll, array<ll, 2>> st(a);
	for (int t = 0; t < q; t++) {
		int type, a, b;
		cin >> type >> a >> b;
		a--;
		b--;
		if (type == 1) {
			int x;
			cin >> x;
			st.range_update(a, b, {0, x});
		} else if (type == 2) {
			int x;
			cin >> x;
			st.range_update(a, b, {x, 0});
		} else {
			cout << st.range_sum(a, b) << '\n';
		}
	}
}
```

### Tutorial

<Resources>
	<Resource
		source="CF EDU"
		title="Segment Tree Pt 2"
		url="https://codeforces.com/edu/course/2/lesson/5"
		starred
	 />
	<Resource source="CPH" title="28.1 - Segment Trees Revisited" starred>
		short description
	</Resource>
	<Resource source="CSA" title="Segment Trees" url="segment_trees" starred>
		interactive
	</Resource>
	<Resource
		source="cp-algo"
		title="Segment Tree"
		url="data_structures/segment_tree.html"
		starred
	>
		adding on segments, assigning
	</Resource>
	<Resource source="CF" title="Efficient and easy segment trees" url="18051">
		code is more confusing than recursive version
	</Resource>
</Resources>

### Problems

<Problems problems="lazySegTree" />
