---
id: leetcode-96
source: Leetcode
title: Unique Binary Search Trees
author: Rameez Parwez
---

## Explanation

The number of structurally unique Binary Search Trees (BST) for $n$ nodes is the $n^{th}$ catalan number.

## Solution 1 - Using Binomial Coeffiecients

$$
C_n=\frac{1}{n+1}\cdot \binom{2n}{n}=\frac{(2n)!}{(n+1)!\,n!}
$$

**Time Complexity:** $\mathcal{O}(N)$

<LanguageSection>

<CPPSection>
```cpp
class Solution {
  public:
#define i23 long long

	i23 nCr(int n, int k) {
		i23 res = 1;

		// since C(n, k) = C(n, n - k)
		if (k > n - k) { k = n - k; }

		for (int i = 0; i < k; i++) {
			res *= (n - i);
			res /= (i + 1);
		}

		return res;
	}
	int numTrees(int n) {
		int res = nCr(2 * n, n) / (n + 1);
		return res;
	}
};
```
</CPPSection>

<PySection>
```py
import math


class Solution:
	def numTrees(self, n: int) -> int:
		res = math.comb(2 * n, n) // (n + 1)
		return res
```
</PySection>

</LanguageSection>


## Solution 2 - Using Recurrence Formula

$$
C_{n+1}= \sum^{n}_{i=0}{C_i \cdot C_{n-i}} \,\,\, \text{ for } n \ge 0 \\
$$

**Time Complexity:** $\mathcal{O} (N^2)$

<LanguageSection>

<CPPSection>
```cpp
class Solution {
  public:
	int numTrees(int n) {
		vector<int> dp(n + 1);
		dp[0] = dp[1] = 1;

		for (int i = 2; i <= n; ++i) {
			for (int j = 1; j <= i; ++j) { dp[i] += dp[j - 1] * dp[i - j]; }
		}

		return dp[n];
	}
};
```
</CPPSection>

<PySection>
```py
class Solution:
	def numTrees(self, n: int) -> int:
		dp = [0] * (n + 1)
		dp[0], dp[1] = 1, 1

		for i in range(2, n + 1):
			for j in range(1, i + 1):
				dp[i] += dp[j - 1] * dp[i - j]

		return dp[n]
```
</PySection>

</LanguageSection>
