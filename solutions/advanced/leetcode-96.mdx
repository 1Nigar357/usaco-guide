---
id: leetcode-96
source: Leetcode
title: Unique Binary Search Trees
author: Rameez Parwez
---

## Explanation

The number of structurally unique Binary Search Trees (BST) for $n$ nodes is the $n^{th}$ catalan number.

<Spoiler title = "Proof">
Let's consider a binary search tree(BST) where we choose $k$ as the root. In this case:
- The left subtree will consist of $k - 1$ nodes, containing all values less than $k$.
- The right subtree will consist of $n - k$ nodes, containing all values greater than $k$.

Therefore, the problem of counting the number of unique BSTs with $n$ nodes can be broken down into counting the number of unique BSTs that can be formed with $k - 1$ nodes in the left subtree and $n - k$ nodes in the right subtree.

Let $C_n$ be the number of unique BSTs that can be formed with $n$ nodes.

Since the the root of the tree can be any one of the $n$ values, the total number of BSTs with $n$ nodes is the sum of the number of BSTs formed by combining all possible left and right subtrees:

$$
C_n= \sum^{n}_{k=1}{C_{k - 1} \cdot C_{n - k}}
$$

This recursive formula is exactly the same as the recursive definition of the Catalan number:

$$
C_n=\frac{1}{n+1}\cdot \binom{2n}{n}
$$

Thus, the number of structurally unique BSTs with $n$ nodes corresponds to the $n^{th}$ Catalan number.

</Spoiler>

## Implementation

**Time Complexity:** $\mathcal{O}(N)$

<LanguageSection>

<CPPSection>
```cpp
class Solution {
  public:
#define i23 long long

	i23 nCr(int n, int k) {
		i23 res = 1;

		// since C(n, k) = C(n, n - k)
		if (k > n - k) { k = n - k; }

		for (int i = 0; i < k; i++) {
			res *= (n - i);
			res /= (i + 1);
		}

		return res;
	}
	int numTrees(int n) {
		int res = nCr(2 * n, n) / (n + 1);
		return res;
	}
};
```
</CPPSection>

<PySection>
```py
import math

class Solution:
	def numTrees(self, n: int) -> int:
		res = math.comb(2 * n, n) // (n + 1)
		return res
```
</PySection>

</LanguageSection>
