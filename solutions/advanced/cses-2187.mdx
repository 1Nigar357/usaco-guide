---
id: cses-2187
source: CSES
title: Bracket Sequences II
author: Mihnea Brebenel
---

## Explanation

First, it would be helpful to know how many open and closed brackets should be in the remaining sequence; let $c$ and $n$ 
denote the number of closed brackets and the length of the remaining sequence. Then, the number of possible endings -
not necessarily valid - is ${n \choose c}$.

Second, not all ${n \choose c}$ endings are valid, so by counting the invalid endings we'll know that the rest must be valid.
To count the invalid endings, flip the brackets in the suffix beginning from the firt position the sequence becomes invalid,
resulting in $c+1$ closed brackets, thus the number of invalid endings is ${n \choose c+1}$. The answer is the difference between
the two: ${n \choose c} - {n \choose c+1}$. Let's take a look at the example for $n=6$ and the prefix $\texttt{(()}$:
- $\texttt{(()))(}$  this is the only invalid sequence from all ${3 \choose 2}$ endings. It becomes invalid at 
5-th bracket. Now, flip the rest, i.e. the last bracket, and will get $\texttt{(())))}$ . The answer is 
${3 \choose 2}$ - ${3 \choose 3}=3-1=2$.

## Implementation

**Time Complexity:** $\mathcal{O}(N)$

<LanguageSection>
<CPPSection>

```cpp
#include <iostream>
 
using namespace std;
 
const int MAXN = 1e6;
const int MOD = 1e9 + 7;
 
// BeginCodeSnip{Combinatorics Functions (from module)}
long long fac[MAXN + 1];
long long inv[MAXN + 1];
 
/** @return x^n modulo m in O(log p) time. */
long long exp(long long x, long long n, long long m) {
	x %= m;  // note: m * m must be less than 2^63 to avoid ll overflow
	long long res = 1;
	while (n > 0) {
		if (n % 2 == 1) { res = res * x % m; }
		x = x * x % m;
		n /= 2;
	}
	return res;
}
 
/** Precomputes n! from 0 to MAXN. */
void factorial(long long p) {
	fac[0] = 1;
	for (int i = 1; i <= MAXN; i++) { fac[i] = fac[i - 1] * i % p; }
}
 
/**
 * Precomputes all modular inverse factorials
 * from 0 to MAXN in O(n + log p) time
 */
void inverses(long long p) {
	inv[MAXN] = exp(fac[MAXN], p - 2, p);
	for (int i = MAXN; i >= 1; i--) { inv[i - 1] = inv[i] * i % p; }
}
 
/** @return nCr mod p */
long long choose(long long n, long long r, long long p) {
	return fac[n] * inv[r] % p * inv[n - r] % p;
}
// EndCodeSnip
 
int main() { 
	int n;
	string s;
	cin >> n >> s;
	
	// Odd length strings have no solution
	if(n % 2) {
		cout << 0 << endl;
		return 0;
	}
	
	// Count the open/closed brackets
	int closed = 0, open = 0;
	for(int i = 0; i < s.size(); i++) {
		closed += (s[i] == ')');
		open += (s[i] == '(');	
		// The string becomes invalid
		if(closed > open) {
			cout << 0 << endl;
			return 0;
		}
	}
 
	// Too many open brackets
	if(2 * open > n) {
		cout << 0 << endl;
		return 0;
	}
	// Get the size of the remaining string
	n -= s.size();
	
	// Precompute combinatorial values
	factorial(MOD);
	inverses(MOD);
	
	// Count the # of remaining open brackets in the suffix
	int remaining_closed = (n + open - closed) / 2;
	// Substract from the total # of valid string the # of invalid strings
	cout << ( choose(n, remaining_closed, MOD) - choose(n, remaining_closed + 1, MOD) + MOD ) % MOD << endl;
}
```

</CPPSection>
</LanguageSection>