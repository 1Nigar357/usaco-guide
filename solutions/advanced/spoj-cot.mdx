---
id: spoj-cot
source: SPOJ
title: Count on a tree
author: Nigar Hajiyeva
---
## Explanation


In this code, a persistent segment tree is built for each node in the tree by creating a new version based on its parent’s segment tree.

First, a persistent segment tree for the root node which shows the frequency of the values encountered is built. We set all of the values of this tree to zeros. To incorporate the value of the current node, we create a new version of the segment tree by adding nodes to the parent’s tree and incrementing the segment tree node corresponding to the current node’s value. We store the root node of the new version of the tree for future reference. This way we don't need to build a completely new tree and modify only the necessary nodes while reusing the unchanged parts.

Each persistent segment tree keeps the frequency of numbers on the way from the root of the tree given in the input to itself. When asked for the kth minimum node in the path of $u$ to $v$, the code first determines the lowest common ancestor (LCA) of the tree in the input using binary lifting. Next, we run a binary search using the frequency values from the persistent segment tree versions of four nodes: $u$, $v$, the LCA, and the parent of the LCA.

Since the values that are not on the path of $u$ and $v$, but on the path from the root node to the nodes $u$ and $v$ are also counted in their persistent segment trees, just considering their persistent segment trees would produce the wrong results.

![example](spoj-cot/example.png)

**Handling Overcounting with LCA**

We subtract the frequencies of nodes from the root node to the LCA and its parent because we count the nodes twice from the root node to the LCA. In addition, since the LCA is on the path of $u$ to $v$, we subtract the frequencies from the LCA and the parent of the LCA to consider the value of the LCA.

$$
\texttt{leftCountFromUToV} = \texttt{leftCount}[\texttt{$u$}]+\texttt{leftCount}[\texttt{$v$}]−\texttt{leftCount}[\texttt{LCA}]−\texttt{leftCount}[\texttt{parentOfLCA}]
$$



**Note:**
Value compression is used to effectively handle large numbers.

## Implementation

**Time Complexity:** $\mathcal{O}((N+M) \cdot \log{N})$

<LanguageSection>
<CPPSection>

```cpp

#include <bits/stdc++.h>
using namespace std;
const int MAX = 2e5 + 10, MAX_NODES = 2e6, LOG = 20;
int L[MAX_NODES + 1], R[MAX_NODES + 1], t[MAX_NODES + 1], roots[MAX + 1],
    up[MAX + 1][LOG + 1];
int tin[MAX + 1], tout[MAX + 1], val[MAX + 1];
vector<int> graph[MAX + 1];
int nxt = 1, timer = 0;

int update(int v, int l, int r, int pos) {
	int nw = ++nxt;

	if (l == r) {
		t[nw] = t[v] + 1;
		return nw;
	}

	L[nw] = L[v];
	R[nw] = R[v];
	int m = (l + r) / 2;

	if (pos <= m) {
		L[nw] = update(L[v], l, m, pos);
	} else {
		R[nw] = update(R[v], m + 1, r, pos);
	}

	t[nw] = t[L[nw]] + t[R[nw]];
	return nw;
}

void dfs(int from, int p) {
	int root = roots[p];
	root = update(root, 1, MAX, val[from]);

	roots[from] = root;
	tin[from] = ++timer;

	if (from != 1) {
		up[from][0] = p;
	} else {
		up[from][0] = from;
	}

	for (int i = 1; i < LOG; i++) { up[from][i] = up[up[from][i - 1]][i - 1]; }

	for (int to : graph[from]) {
		if (to == p) continue;
		dfs(to, from);
	}
	tout[from] = timer;
}

bool is_ancestor(int u, int v) { return tin[u] <= tin[v] && tout[u] >= tout[v]; }

int lca(int u, int v) {
	if (is_ancestor(u, v)) return u;
	if (is_ancestor(v, u)) return v;
	for (int i = LOG - 1; i >= 0; i--) {
		if (is_ancestor(up[u][i], v)) continue;
		u = up[u][i];
	}
	return up[u][0];
}

int query(int a, int b, int anc, int pr, int l, int r, int k) {
	if (l == r) { return l; }
	int m = (l + r) / 2;
	int cnt = t[L[a]] + t[L[b]] - t[L[anc]] - t[L[pr]];
	if (cnt >= k) return query(L[a], L[b], L[anc], L[pr], l, m, k);
	else return query(R[a], R[b], R[anc], R[pr], m + 1, r, k - cnt);
}

int main() {
	int n, m;
	cin >> n >> m;
	vector<int> compr;
	compr.push_back(-INT_MAX);

	for (int i = 1; i <= n; i++) {
		cin >> val[i];
		compr.push_back(val[i]);
	}

	sort(compr.begin(), compr.end());
	compr.resize(unique(compr.begin(), compr.end()) - compr.begin());

	for (int i = 1; i <= n; i++) {
		val[i] = lower_bound(compr.begin(), compr.end(), val[i]) - compr.begin();
	}

	for (int i = 1; i < n; i++) {
		int a, b;
		cin >> a >> b;
		graph[a].push_back(b);
		graph[b].push_back(a);
	}

	roots[0] = ++timer;
	dfs(1, 0);

	for (int i = 0; i < m; i++) {
		int a, b, k;
		cin >> a >> b >> k;
		int common = lca(a, b);
		int pr = (common == 1) ? 0 : up[common][0];
		cout << compr[query(roots[a], roots[b], roots[common], roots[pr], 1, MAX, k)]
		     << '\n';
	}
}
```

</CPPSection>
</LanguageSection>
