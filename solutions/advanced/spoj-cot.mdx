---
id: spoj-cot
source: SPOJ
title: Count on a tree
author: Nigar Hajiyeva
---
## Explanation

This code solves the "Count on a Tree" problem using a persistent segment tree.
In this code, a persistent segment tree is built for each node in the tree by modifying that of its parent.

Each persistent segment tree keeps the frequency of numbers on the way from the root node to itself. When asked for the kth minimum node in the path of u to v, the code first determines the lowest common ancestor (LCA). Next, we run a binary search using the frequency values from the persistent segment tree of the three nodes.

<LanguageSection>
<CPPSection>

```cpp

ll cnt = t[L[a]] + t[L[b]] - t[L[anc]] - t[L[pr]];
```

</CPPSection>
</LanguageSection>

Since the values that are not on the path of u and v, but on the path from root node to the nodes u and v, just considering the persistent segment trees of these nodes would produce wrong answers. We subtract the frequencies of nodes from root node to the LCA and its parents because we count the nodes twice from root node to the LCA. In addition, since the lca is on the path of u to v, we subtract the frequencies from the LCA and parents of the LCA to consider the value of the LCA.

Binary lifting is used to find the lowest common ancestor (LCA) of the two nodes to subtract the frequencies of numbers that lie from the root node to the lowest common ancestor. This is used to accurately maintain the count of appearances of numbers on the path from a to b.

**Note:**
Value compression is used to effectively handle large numbers which would potentially create a problem when used for indexing.

**Time Complexity:** $\mathcal{O}((N+M) \cdot \log{N})$


## Implementation

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define vi vector<ll>
#define pb push_back
#define endl '\n'
const int MAX = 2e5 + 10, MAX_NODES = 7e6, LOG = 20;
int L[MAX_NODES + 1], R[MAX_NODES + 1], t[MAX_NODES + 1], trs[MAX + 1],
    up[MAX + 1][LOG + 1];
int tin[MAX + 1], tout[MAX + 1], val[MAX + 1];
vi g[MAX + 1];
ll nxt = 0, timer = 0;

int build(int v, int l, int r) {
	int nw = ++nxt;
	if (l == r) { return nw; }
	int m = (l + r) / 2;
	L[v] = build(nw, l, m);
	R[v] = build(nw, m + 1, r);
	return nw;
}

ll update(int v, int l, int r, int pos) {
	int nw = ++nxt;

	if (l == r) {
		t[nw] += t[v] + 1;
		return nw;
	}

	L[nw] = L[v];
	R[nw] = R[v];
	int m = (l + r) / 2;

	if (pos <= m) {
		L[nw] = update(L[v], l, m, pos);
	} else {
		R[nw] = update(R[v], m + 1, r, pos);
	}

	t[nw] = t[L[nw]] + t[R[nw]];
	return nw;
}

void dfs(int from, int p) {
	int root = trs[p];
	root = update(root, 1, MAX, val[from]);

	trs[from] = root;
	tin[from] = ++timer;

	if (from != 1) {
		up[from][0] = p;
	} else {
		up[from][0] = from;
	}

	for (int i = 1; i < LOG; i++) { up[from][i] = up[up[from][i - 1]][i - 1]; }

	for (int to : g[from]) {
		if (to == p) continue;
		dfs(to, from);
	}
	tout[from] = timer;
}

bool is_ancestor(int u, int v) { return tin[u] <= tin[v] && tout[u] >= tout[v]; }

int lca(int u, int v) {
	if (is_ancestor(u, v)) return u;
	if (is_ancestor(v, u)) return v;
	for (int i = LOG - 1; i >= 0; i--) {
		if (is_ancestor(up[u][i], v)) continue;
		u = up[u][i];
	}
	return up[u][0];
}

ll query(int a, int b, int anc, int pr, int l, int r, int k) {
	if (l == r) { return l; }
	int m = (l + r) / 2;
	ll cnt = t[L[a]] + t[L[b]] - t[L[anc]] - t[L[pr]];
	if (cnt >= k) return query(L[a], L[b], L[anc], L[pr], l, m, k);
	else return query(R[a], R[b], R[anc], R[pr], m + 1, r, k - cnt);
}

int main() {
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n, m;
	cin >> n >> m;
	vi compr;
	compr.pb(-INT_MAX);

	for (int i = 1; i <= n; i++) {
		cin >> val[i];
		compr.pb(val[i]);
	}

	sort(compr.begin(), compr.end());
	compr.resize(unique(compr.begin(), compr.end()) - compr.begin());

	for (int i = 1; i <= n; i++) {
		val[i] = lower_bound(compr.begin(), compr.end(), val[i]) - compr.begin();
	}

	for (int i = 1; i < n; i++) {
		int a, b;
		cin >> a >> b;
		g[a].pb(b);
		g[b].pb(a);
	}

	trs[0] = build(nxt, 1, MAX);
	dfs(1, 0);

	for (int i = 0; i < m; i++) {
		int a, b, k;
		cin >> a >> b >> k;
		int common, pr;
		common = lca(a, b);
		pr = up[common][0];
		if (common == 1) { pr = 0; }
		cout << compr[query(trs[a], trs[b], trs[common], trs[pr], 1, MAX, k)] << endl;
	}
}
```

</CPPSection>
</LanguageSection>
