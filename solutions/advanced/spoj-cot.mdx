---
id: spoj-cot
source: SPOJ
title: Count on a tree
author: Nigar Hajiyeva
---
## Explanation

This code solves the "Count on a Tree" problem using a persistent segment tree. It efficiently handles queries on a tree to find the k-th smallest value in the path between two nodes.

**Key steps:**

Persistent Segment Tree Construction: Builds a segment tree where each update creates a new version, allowing access to historical states.

DFS for Tree Traversal: Computes entry/exit times (tin/tout) and initializes the segment tree for each node.

LCA Calculation: Uses binary lifting to find the Lowest Common Ancestor (LCA) of two nodes.

Value Compression: Compresses the node values to handle large numbers efficiently, making them suitable for indexing in the segment tree.


**Time Complexity:** $\mathcal{O}((N+M) \cdot \log{N})$

## Implementation

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define vi vector<ll>
#define pb push_back
#define INF 100000000000

const int MAX = 2e5 + 10, MAX_NODES = 7e6, LOG = 20;
int L[MAX_NODES + 1], R[MAX_NODES + 1], t[MAX_NODES + 1], trs[MAX + 1],
    up[MAX + 1][LOG + 1];
int tin[MAX + 1], tout[MAX + 1], val[MAX + 1];
vi g[MAX + 1];
ll nxt = 0, timer = 0;

int build(int v, int l, int r) {
	int nw = ++nxt;
	if (l == r) { return nw; }
	int m = (l + r) / 2;

	L[v] = build(nw, l, m);
	R[v] = build(nw, m + 1, r);
	return nw;
}

ll update(int v, int l, int r, int pos) {
	int nw = ++nxt;

	if (l == r) {
		t[nw] += t[v] + 1;
		return nw;
	}

	L[nw] = L[v];
	R[nw] = R[v];
	int m = (l + r) / 2;

	if (pos <= m) L[nw] = update(L[v], l, m, pos);
	else R[nw] = update(R[v], m + 1, r, pos);

	t[nw] = t[L[nw]] + t[R[nw]];
	return nw;
}

void dfs(int from, int p) {
	int root = trs[p];
	root = update(root, 1, MAX, val[from]);

	trs[from] = root;
	tin[from] = ++timer;

	if (from != 1) up[from][0] = p;
	else up[from][0] = from;

	for (int i = 1; i <= LOG - 1; i++) { up[from][i] = up[up[from][i - 1]][i - 1]; }

	for (int to : g[from]) {
		if (to == p) continue;
		dfs(to, from);
	}
	tout[from] = timer;
}

bool is_ancestor(int u, int v) { return tin[u] <= tin[v] && tout[u] >= tout[v]; }

int lca(int u, int v) {
	if (is_ancestor(u, v)) return u;
	if (is_ancestor(v, u)) return v;
	for (int i = LOG - 1; i >= 0; i--) {
		if (is_ancestor(up[u][i], v)) continue;
		u = up[u][i];
	}
	return up[u][0];
}

ll query(int a, int b, int anc, int pr, int l, int r, int k) {
	if (l == r) { return l; }
	int m = (l + r) / 2;
	ll cnt = t[L[a]] + t[L[b]] - t[L[anc]] - t[L[pr]];
	if (cnt >= k) return query(L[a], L[b], L[anc], L[pr], l, m, k);
	else return query(R[a], R[b], R[anc], R[pr], m + 1, r, k - cnt);
}

int main() {
	// input variables
	int n, m;
	cin >> n >> m;
	vi compr;
	compr.pb(-INF);

	for (int i = 1; i <= n; i++) {
		cin >> val[i];
		compr.pb(val[i]);
	}

	sort(compr.begin(), compr.end());
	compr.resize(unique(compr.begin(), compr.end()) - compr.begin());

	for (int i = 1; i <= n; i++) {
		val[i] = (lower_bound(compr.begin(), compr.end(), val[i]) - compr.begin());
	}

	int a, b, k, common, pr;
	for (int i = 1; i < n; i++) {
		cin >> a >> b;
		g[a].pb(b);
		g[b].pb(a);
	}

	trs[0] = build(nxt, 1, MAX);
	dfs(1, 0);

	for (int i = 0; i < m; i++) {
		cin >> a >> b >> k;
		common = lca(a, b);
		pr = up[common][0];
		if (common == 1) pr = 0;
		cout << compr[query(trs[a], trs[b], trs[common], trs[pr], 1, MAX, k)] << endl;
	}
}
```

</CPPSection>
</LanguageSection>
