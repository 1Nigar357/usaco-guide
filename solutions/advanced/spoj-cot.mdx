---
id: spoj-cot
source: SPOJ
title: Count on a tree
author: Nigar Hajiyeva
---
## Explanation

In this code, a persistent segment tree is built for each node in the tree by modifying that of its parent.
It takes the persistent segment tree of the parent node, adds the value of the current node by adding nodes to the persistent segment tree of the parent node, and stores the root node of the new tree. This way we we don't need to build a completely new tree and can just modify the nodes that require a change.

Each persistent segment tree keeps the frequency of numbers on the way from the root of the tree given in the input to itself. When asked for the kth minimum node in the path of u to v, the code first determines the lowest common ancestor (LCA) of the tree in the input. Next, we run a binary search using the frequency values from the persistent segment tree of four nodes: u, v, the LCA, and the parent of the LCA.

Since the values that are not on the path of u and v, but on the path from the root node to the nodes u and v are also counted in their persistent segment trees, just considering their persistent segment trees would produce wrong results.

**Handling Overcounting with LCA**

We subtract the frequencies of nodes from the root node to the LCA and its parent because we count the nodes twice from the root node to the LCA. In addition, since the LCA is on the path of u to v, we subtract the frequencies from the LCA and the parent of the LCA to consider the value of the LCA.

$$
\texttt leftCountFromUToV = leftCount[u]+leftCount[v]−leftCount[LCA]−leftCount[parentOfLCA]
$$

![example](spoj-cot/example.png)

Binary lifting is used to find the lowest common ancestor (LCA) of the two nodes to subtract the frequencies of numbers that lie from the root node to the lowest common ancestor. This is used to accurately maintain the count of appearances of numbers on the path from a to b.

**Note:**
Value compression is used to effectively handle large numbers which would potentially create a problem when used for indexing.


## Implementation

**Time Complexity:** $\mathcal{O}((N+M) \cdot \log{N})$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int MAX = 2e5 + 10, MAX_NODES = 7e6, LOG = 20;
int L[MAX_NODES + 1], R[MAX_NODES + 1], t[MAX_NODES + 1], trs[MAX + 1],
    up[MAX + 1][LOG + 1];
int tin[MAX + 1], tout[MAX + 1], val[MAX + 1];
vector<int> graph[MAX + 1];
ll nxt = 0, timer = 0;

int build(int v, int l, int r) {
	int nw = ++nxt;
	if (l == r) { return nw; }
	int m = (l + r) / 2;
	L[v] = build(nw, l, m);
	R[v] = build(nw, m + 1, r);
	return nw;
}

ll update(int v, int l, int r, int pos) {
	int nw = ++nxt;

	if (l == r) {
		t[nw] += t[v] + 1;
		return nw;
	}

	L[nw] = L[v];
	R[nw] = R[v];
	int m = (l + r) / 2;

	if (pos <= m) {
		L[nw] = update(L[v], l, m, pos);
	} else {
		R[nw] = update(R[v], m + 1, r, pos);
	}

	t[nw] = t[L[nw]] + t[R[nw]];
	return nw;
}

void dfs(int from, int p) {
	int root = trs[p];
	root = update(root, 1, MAX, val[from]);

	trs[from] = root;
	tin[from] = ++timer;

	if (from != 1) {
		up[from][0] = p;
	} else {
		up[from][0] = from;
	}

	for (int i = 1; i < LOG; i++) { up[from][i] = up[up[from][i - 1]][i - 1]; }

	for (int to : graph[from]) {
		if (to == p) continue;
		dfs(to, from);
	}
	tout[from] = timer;
}

bool is_ancestor(int u, int v) { return tin[u] <= tin[v] && tout[u] >= tout[v]; }

int lca(int u, int v) {
	if (is_ancestor(u, v)) return u;
	if (is_ancestor(v, u)) return v;
	for (int i = LOG - 1; i >= 0; i--) {
		if (is_ancestor(up[u][i], v)) continue;
		u = up[u][i];
	}
	return up[u][0];
}

ll query(int a, int b, int anc, int pr, int l, int r, int k) {
	if (l == r) { return l; }
	int m = (l + r) / 2;
	ll cnt = t[L[a]] + t[L[b]] - t[L[anc]] - t[L[pr]];
	if (cnt >= k) return query(L[a], L[b], L[anc], L[pr], l, m, k);
	else return query(R[a], R[b], R[anc], R[pr], m + 1, r, k - cnt);
}

int main() {
	int n, m;
	cin >> n >> m;
	vector<int> compr;
	compr.push_back(-INT_MAX);

	for (int i = 1; i <= n; i++) {
		cin >> val[i];
		compr.push_back(val[i]);
	}

	sort(compr.begin(), compr.end());
	compr.resize(unique(compr.begin(), compr.end()) - compr.begin());

	for (int i = 1; i <= n; i++) {
		val[i] = lower_bound(compr.begin(), compr.end(), val[i]) - compr.begin();
	}

	for (int i = 1; i < n; i++) {
		int a, b;
		cin >> a >> b;
		graph[a].push_back(b);
		graph[b].push_back(a);
	}

	trs[0] = build(nxt, 1, MAX);
	dfs(1, 0);

	for (int i = 0; i < m; i++) {
		int a, b, k;
		cin >> a >> b >> k;
		int common, pr;
		common = lca(a, b);
		pr = up[common][0];
		if (common == 1) { pr = 0; }
		cout << compr[query(trs[a], trs[b], trs[common], trs[pr], 1, MAX, k)] << endl;
	}
}
```

</CPPSection>
</LanguageSection>
