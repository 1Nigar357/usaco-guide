---
id: usaco-816
source: USACO Platinum February 2018
title: Slingshot
author: Justin Ji
---

## Explanation

If we need to move from $a$ to $b$ with a slingshot from $x$ to $y$ that takes
$t$ time, then it will take $abs(a - x) + abs(b - y) + t$ time.

To eliminate the absolute values, we have to do a bit of casework. Note that
the result for using a given slingshot is always in the form of 
$t + (\pm a \pm x) + (\pm b \pm y)$; because we are doing casework on the signs,
we can separate the cost for using a slingshot from the values of $a$ and $b$.

So, we can consider each of the four cases and use a range minimum segment tree 
to keep track of the best slingshots for each prefix/suffix of the array.
My implementation processes the four cases in two iterations, where in one 
iteration $a \leq x$, and in the other $a \geq x$.

## Implementation

**Time Complexity:** $\mathcal{O}((N + Q) \log{N})$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

template <class T> class MinSegmentTree {
  private:
	const T DEFAULT = numeric_limits<T>().max();

	vector<T> segtree;
	int len;

  public:
	MinSegmentTree(int len) : len(len), segtree(len * 2, DEFAULT) {}

	void set(int ind, T val) {
		ind += len;
		segtree[ind] = val;
		for (; ind > 1; ind /= 2) {
			segtree[ind / 2] = min(segtree[ind], segtree[ind ^ 1]);
		}
	}

	T range_min(int start, int end) {
		T res = DEFAULT;
		for (start += len, end += len; start < end; start /= 2, end /= 2) {
			if (start % 2 == 1) { res = min(res, segtree[start++]); }
			if (end % 2 == 1) { res = min(res, segtree[--end]); }
		}
		return res;
	}

    T get(int ind) { return segtree[len + ind]; }
};

int main() {
    freopen("slingshot.in", "r", stdin);
    freopen("slingshot.out", "w", stdout);
    int n, q;
    cin >> n >> q;
    vector<array<int, 4>> events;
    vector<int> coords = {0, INT_MAX};
    for (int i = 0; i < n; i++) {
        int x, y, t;
        cin >> x >> y >> t;
        coords.push_back(x);
        coords.push_back(y);
        events.push_back({0, x, y, t});
    }
    for (int i = 0; i < q; i++) {
        int a, b;
        cin >> a >> b;
        coords.push_back(a);
        coords.push_back(b);
        events.push_back({1, a, b, i});
    }

    // apply coordinate compression on all relevant locations
    sort(begin(coords), end(coords));
    coords.erase(unique(begin(coords), end(coords)), end(coords));
    const auto id = [&](int x) -> int {
        return lower_bound(begin(coords), end(coords), x) - begin(coords);
    };

    constexpr ll INF = 1e18;
    vector<ll> res(q, INF);
    for (int t = 0; t < 2; t++) {
        /*
         * x <= a if t = 0.
         * x >= a if t = 1.
         * We always place the slingshot events before
         * the query events in our sorting order.
         */
        sort(begin(events), end(events), 
            [&](const array<int, 4> &x, const array<int, 4> &y) -> bool {
            int v_1 = x[1], v_2 = y[1];
            if (t == 0) { v_1 *= -1, v_2 *= -1; }
            return (v_1 == v_2) ? x[0] < y[0] : v_1 < v_2;
        });

        /*
         * pref = RMQ for best option if b <= y
         * suff = RMQ for best option if b >= y
         */
        MinSegmentTree<ll> pref(coords.size());
        MinSegmentTree<ll> suff(coords.size());
        for (const auto [type, a, b, c] : events) {
            int b_id = id(b);
            if (type == 0) {
                // applying this result for future queries where b <= y.
                ll add_1 = (t) ? c - a - b : c + a - b;
                if (pref.get(b_id) > add_1) {
                    pref.set(b_id, add_1);
                }

                // applying this result for future queries where b >= y.
                ll add_2 = (t) ? c - a + b : c + a + b;
                if (suff.get(b_id) > add_2) {
                    suff.set(b_id, add_2);
                }
            } else {
                // res_1 is for if we are choosing a slingshot with b <= y
                // res_2 is for if we are choosing a slingshot with b >= y
                ll res_1 = min(INF, pref.range_min(0, b_id + 1));
                ll res_2 = min(INF, suff.range_min(b_id, coords.size()));

                if (t == 0) {
                    res_1 += b - a;
                    res_2 -= a + b;
                } else {
                    res_1 += a + b;
                    res_2 += a - b;
                }

                res[c] = min({res[c], res_1, res_2, (ll) abs(a - b)});
            }
        }
    }
    for (int i = 0; i < q; i++) {
        cout << res[i] << "\n";
    }
}
```

</CPPSection>
</LanguageSection>