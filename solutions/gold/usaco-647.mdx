---
id: usaco-647
source: USACO Gold 2016 Open
title: '248'
author: Melody Yu, Qi Wang, Rohak Debnath
---

[Official Analysis (Java)](http://www.usaco.org/current/data/sol_248_gold_open16.html)

## Video Solution

Note: The video solution might not be the same as other solutions. Code in C++.
<YouTube id="OdHxOYICx-o" />

## Explanation

Let's begin by thinking about what should be the natural first thought while solving this problem. Consider a range $A[i..j]$, and think about the ways in which we can proceed. Since elements need to be adjacent to be merged into one larger element, and the elements we are merging could in return be the result of a merging process of a subarray, it is natural to think about subarrays of the subarray $A[i..j]$. Along with the constraint on $N$ being less than 248, this hints towards range DP.

Let us define $dp[i][j]$ as the subarray of $A$ (with $i$ and $j$ inclusive and 0-based) such that $dp[i][j]$ is the element it can be merged into as a single element. If it cannot be merged into a single element, let it be \(-1\). For an iterator $k$ ranging from $i$ to $j-1$, we can check for the following transitions:

1. If $i == j$, $dp[i][j] = a[i]$ (base case).
2. Otherwise, if $dp[i][k] \neq -1$ and $dp[i][k] == dp[k+1][j]$, then $dp[i][j] = dp[i][k] + 1$.

For every range $i..j$, we are checking if it can be merged into a single element or not, which can be determined by considering parts of the range that can be turned into the same number. Then set $dp[i][j]$ as 1 plus the value of those ranges that are equal. It can be helpful to notice that a range that can be merged into a single element will only merge into a particular number. Hence, it is not necessary to write the transitions as $dp[i][j] = \max(dp[i][j], dp[i][k] + 1)$, as it can only be one number, if at all.



## Implementation

**Time Complexity:** $\mathcal{O}(N^3)$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>

using namespace std;
using i64 = long long;

void setIO(string name = "") {
	if (!name.empty()) {
		freopen((name + ".in").c_str(), "r", stdin);
		freopen((name + ".out").c_str(), "w", stdout);
	}
}

int main() {
	setIO("248");
	int n;
	cin >> n;
	vector<int> a(n);
	for (int i = 0; i < n; ++i) cin >> a[i];
	vector<vector<int>> dp(
	    n, vector<int>(n, -1));  // dp[i][j] = final element the range i..j can
	                             // be merged into as a single element, -1 if it
	                             // cannot be merged into a single element
	int ans = 0;
	for (int i = n - 1; i >= 0; --i) {
		for (int j = i; j < n; ++j) {
			if (i == j) {
				dp[i][j] = a[i];
			} else {
				for (int k = i; k < j; ++k) {
					if (dp[i][k] != -1 and dp[i][k] == dp[k + 1][j]) {
						dp[i][j] = dp[i][k] + 1;
					}
				}
			}
			ans = max(ans, dp[i][j]);
		}
	}
	cout << ans << '\n';
	return 0;
}
```
</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class U248 {
	public static void main(String[] args) throws IOException {
		Kattio io = new Kattio("248");

		int N = io.nextInt();
		int[] board = new int[N];

		int[][] dp = new int[N + 1][N + 1];
		for (int i = 0; i < N; i++) {
			board[i] = io.nextInt();
			dp[i + 1][i + 1] = board[i];
		}

		int max_val = 0;
		for (int i = N - 1; i >= 1; i--) {
			for (int j = i + 1; j <= N; j++) {
				for (int k = i; k < j; k++) {
					if (dp[i][k] == dp[k + 1][j]) {
						dp[i][j] = Math.max(dp[i][j], dp[i][k] + 1);
					}
				}

				max_val = Math.max(max_val, dp[i][j]);
			}
		}

		io.println(max_val);
		io.close();
	}

	// CodeSnip{Kattio}
}
```

</JavaSection>
</LanguageSection>
