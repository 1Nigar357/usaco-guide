---
id: cses-3221
source: CSES
title: Sliding Window Minimum
author: Rameez Parwez
---

[Official Analysis] (https://cp-algorithms.com/data_structures/stack_queue_modification.html#queue-modification-method-1)

## Implementation

**Time Complexity**: $\mathcal{O}(N)$

<LanguageSection>

<CPPSection>
```cpp
#include <bits/stdc++.h>

int main() {
	int n, k;
	std::cin >> n >> k;
	std::vector<int> arr(n);
	for (auto &x : arr) {
		std::cin >> x;
	}

	std::deque<int> d;
	std::vector<int> res;
	for (int i = 0; i < k; i++) {
		while (!d.empty() && arr[i] < arr[d.back()]) { d.pop_back(); }
		d.push_back(i);
	}
	for (int i = k; i < n; i++) {
		res.push_back(arr[d.front()]);

		if (!d.empty() && d.front() == i - k) {
			d.pop_front();	
		}

		while (!d.empty() and arr[i] <= arr[d.back()]) {
			d.pop_back();
		}
		d.push_back(i);
	}
	res.push_back(arr[d.front()]);

	for (int i = 0; i < n - k + 1; i++) {
		std::cout << res[i] << " \n"[i == n - k];
	}
}
```

</CPPSection>

<PySection>

```py
from collections import deque

n, k = map(int, input().split())
arr = list(map(int, input().split()))

d = deque()
res = []

for i in range(k):
    while d and arr[i] < arr[d[-1]]:
        d.pop()
    d.append(i)

for i in range(k, n):
    res.append(arr[d[0]])

    if d and d[0] == i - k:
        d.popleft()

    while d and arr[i] <= arr[d[-1]]:
        d.pop()
    d.append(i)

res.append(arr[d[0]])

print(*res)
```

</PySection>

</LanguageSection>