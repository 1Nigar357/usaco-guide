---
id: rmi-17-Hangman2
source: RMI 2017 Day 1
title: Hangman 2
author: Justin Ji
---

<Spoiler title = "Hint">

Consider breaking the problem into two cases: $n < k$ and $n \geq k$.

</Spoiler>

<Spoiler title = "Explanation">

First, note that $min(n, k) \leq \sqrt{nk}$. This will be important for
analyzing the time complexity of our solution. Now, let's consider the two
cases given in the hint.

### Case 1: $n < k$
Because $n < \sqrt{nk}$, we can brute force each pair of strings and check if
they differ by no more than two characters. This takes $\mathcal{O}(N^2K)$ time,
which is equivalent to $\mathcal{O}(NK\sqrt{NK})$ time.

### Case 2: $n \geq k$
Let's compare two strings. Note how allowing at most two characters to be
different is equivalent to ignoring two characters in both strings and checking
for equality. Thus, we can brute force on every pair of characters that we are
ignoring, and then check for equality between strings.

Let the pair of characters we are brute forcing be $(i, j)$. Then,
we have the following intervals that need to be identical in both strings:

$[0, i - 1], [i + 1, j - 1], [j + 1, k - 1]$

Now, if we want to compare our two strings, then we just need the substrings to
be equal. This can be checked using string hashing.

For each string in our list, we need to find another string that has the same
hashes. This is best done by sorting all the tuples of hashes, and then checking
adjacent items and seeing if the hashes are equal.

Overall, this takes $\mathcal{O}(NK^2\log({N}))$ time. With a bit more analysis,
you can reach the time complexity of $\mathcal{O}(NK\sqrt{NK}\log(\sqrt{NK}))$.

## Implementation

**Time Complexity:** $\mathcal{O}(NK\sqrt{NK}\log(\sqrt{NK}))$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

class HashedString {
  public:
	static const ll M = (1ll << 61) - 1;
	static const ll B;
	static __int128 mul(ll a, ll b) { return (__int128)a * b; }
	static ll mod_mul(ll a, ll b) { return mul(a, b) % M; }

  private:
	static vector<ll> pow;  // pow[i] = P^i % M
	vector<ll> p_hash;      // p_hash[i] = hash of first i characters in string

  public:
	HashedString() {}
	HashedString(const string &s) : p_hash(s.size() + 1) {
		while (pow.size() < s.size()) { pow.push_back(mod_mul(pow.back(), B)); }
		p_hash[0] = 0;
		for (int i = 0; i < (int)s.size(); i++) {
			p_hash[i + 1] = (mul(p_hash[i], B) + s[i]) % M;
		}
	}

	/** @return hash of the substring [l, r] */
	ll get_hash(int l, int r) {
		ll res = p_hash[r + 1] - mod_mul(p_hash[l], pow[r - l + 1]);
		return (res + M) % M;
	}
};
mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());
vector<ll> HashedString::pow = {1};
const ll HashedString::B = uniform_int_distribution<ll>(0, M - 1)(rng);

int main() {
	int tests;
	cin >> tests;
	for (int t = 0; t < tests; t++) {
		int n, k;
		cin >> n >> k;
		vector<string> s(n);
		for (string &i : s) { cin >> i; }

		vector<bool> res(n);
		if (n < k) {
			for (int i = 0; i < n; i++) {
				for (int j = i + 1; j < n; j++) {
					int diff_chars = 0;
					for (int x = 0; x < k; x++) {
						diff_chars += (s[i][x] != s[j][x]);
					}
					if (diff_chars <= 2) { res[i] = res[j] = true; }
				}
			}
		} else {
			vector<HashedString> hashed(n);
			for (int i = 0; i < n; i++) { hashed[i] = HashedString(s[i]); }

			for (int i = 0; i < k; i++) {
				for (int j = i + 1; j < k; j++) {
					vector<array<ll, 4>> intervals(n);
					for (int x = 0; x < n; x++) {
						ll hash_1 = hashed[x].get_hash(0, i - 1);
						ll hash_2 = hashed[x].get_hash(i + 1, j - 1);
						ll hash_3 = hashed[x].get_hash(j + 1, k - 1);
						intervals[x] = {hash_1, hash_2, hash_3, x};
					}

					sort(begin(intervals), end(intervals));
					for (int x = 1; x < n; x++) {
						bool works = true;
						for (int y = 0; y < 3; y++) {
							works &= intervals[x - 1][y] == intervals[x][y];
						}
						if (works) {
							res[intervals[x - 1][3]] = res[intervals[x][3]] =
							    true;
						}
					}
				}
			}
		}

		for (int i = 0; i < n; i++) { cout << res[i]; }
		cout << "\n";
	}
}
```

</CPPSection>
</LanguageSection>

</Spoiler>
