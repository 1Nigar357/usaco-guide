---
id: csa-MountainTime
source: CSA
title: Mountain Time
author: Ryan Chou
---

<Spoiler title="Hint 1">

Instead of thinking of the problem as a grid, think of it as a graph, where we're adding one cell at a time.

In what order should we process these cells?

</Spoiler>

<Spoiler title="Hint 1 (answer)">

We'll process them in decreasing order of height.

</Spoiler>


<Spoiler title="Hint 2">

Whenever we process a cell, we'll want to merge it with all of its neighbors that have already been added (taller than it).

What data structure should we use such that we can efficiently merge two components?

</Spoiler>

<Spoiler title="Hint 2 (answer)">

We can use a [DSU](/gold/dsu) to solve the problem.

</Spoiler>

<Spoiler title="Solution">

## Explanation

Let's imagine that we're currently at cell $x$, which is part of component $A$, and we're merging with some adjacent cell $y$, which is part of component $B$.

We can break it into two cases.

1. The tallest mountains in $A$ and $B$ are the **same** height. In this case, we'll combine all the cells into one component. In the implementation, we use small-to-large merging to minimize the number of cells we have to update.

2. The tallest mountains in $A$ and $B$ are of **different** heights. Without loss of generality, let's assume that mountain $A$ has the tallest mountain. Then, we know the answer for all the cells in component $B$ because $x$ is the tallest mountain that can connect them both.

To simplify the process, we'll root each component at its maximal cell and store indices of components directly in the DSU. This way, we can easily iterate over cells
we've found the answer for.

## Implementation

**Time Complexity:** $\mathcal{O}(NM\log{NM})$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

// BeginCodeSnip{DSU}
struct DSU {
	vector<int> par;
	vector<vector<int>> comp;
	DSU(int N) {
		par = vector<int>(N);
		// every node is its own parent initially
		iota(par.begin(), par.end(), 0);

		comp = vector<vector<int>>(N);
		for (int i = 0; i < N; i++) { comp[i].push_back(i); }
	}

	// get root (uses path compression)
	int get(int x) { return par[x] == x ? x : par[x] = get(par[x]); }

	void unite(int x, int y, vector<int> &grid, vector<int> &ans) {
		int intermediate = grid[x];
		x = get(x), y = get(y);

		if (x == y) { return; }

		if (grid[x] > grid[y]) swap(x, y);

		if (grid[y] > grid[x]) {
			// we have the answer for the smaller component
			for (int &i : comp[x]) {
				ans[i] = intermediate > grid[i] ? 0 : grid[i] - intermediate;
			}

			comp[x].clear();
			par[x] = y;
		} else if (grid[x] == grid[y]) {
			// merge the two components (small to large)
			if ((int)comp[x].size() < (int)comp[y].size()) { swap(x, y); }

			for (int &i : comp[y]) { comp[x].push_back(i); }
			comp[y].clear();
			par[y] = x;
		}
	}
};
// EndCodeSnip

int main() {
	int n, m;
	cin >> n >> m;

	vector<int> grid(n * m);
	vector<int> ans(n * m);

	DSU dsu(n * m);

	vector<pair<int, int>> mountains;
	for (int i = 0; i < n * m; i++) {
		cin >> grid[i];
		ans[i] = grid[i];

		mountains.emplace_back(grid[i], i);
	}

	sort(mountains.begin(), mountains.end());

	// iterate through all cells from tallest to shortest
	while (!mountains.empty()) {
		pair<int, int> cur = mountains.back();
		mountains.pop_back();

		int idx = cur.second;

		if (idx % m != 0 && grid[idx - 1] >= grid[idx]) {
			dsu.unite(idx, idx - 1, grid, ans);  // left
		}

		if (idx >= m && grid[idx - m] >= grid[idx]) {
			dsu.unite(idx, idx - m, grid, ans);  // up
		}

		if (idx % m != m - 1 && grid[idx + 1] >= grid[idx]) {
			dsu.unite(idx, idx + 1, grid, ans);  // right
		}

		if (idx < (n * m) - m && grid[idx + m] >= grid[idx]) {
			dsu.unite(idx, idx + m, grid, ans);  // down
		}
	}

	for (int i = 0; i < n * m; i++) {
		if ((i + 1) % m == 0) {
			cout << ans[i] << endl;
		} else {
			cout << ans[i] << ' ';
		}
	}
}
```

</CPPSection>
</LanguageSection>

</Spoiler>
