---
id: kattis-quantumsuperposition
source: Kattis
title: Quantum Superposition
author: Andrew Wang, Benjamin Qi
---

**Time Complexity:** $\mathcal{O}(\sum NM)$

**Main Idea:** Find all possible lengths of routes in both universes. Then we
can preprocess all possible sums of lengths to answer each query in
$\mathcal{O}(1)$ time.

## Finding All Possible Lengths of Routes

For each node, store all possible lengths of a route that ends at it in a set.
We can do this via DP on the topological sort. When we consider a node, we can
add 1 to all the lengths reaching a previous node and insert them into the set
for the current node. Using a `bitset` rather than a `set` is faster (and gives
slightly shorter code).

We can repeat this process for both universes to find the total lengths of all
paths reaching the end node.

## Finding All Possible Sums

Once we know all possible path lengths for each universe, we can find all
possible sums of lengths. Just loop through both universe's route lengths and
add them together.

<CPPSection>

```cpp
#include <bitset>
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

int n[2], m[2];
vector<int> g[2][1001];
vector<int> back[2][1001];
bitset<2001> dp[2][1001];

void gen(int x) {
	int in_degree[1001] = {};
	for (int i = 0; i < m[x]; i++) {
		int a, b;
		cin >> a >> b;
		g[x][a].push_back(b);
		back[x][b].push_back(a);
		in_degree[b]++;
	}
	// finding length of routes of first universe
	queue<int> q;
	for (int i = 0; i <= n[x]; i++) {
		if (in_degree[i] == 0) { q.push(i); }
	}
	while (!q.empty()) {
		int node = q.front();
		q.pop();
		// using dp while processing the nodes topologically
		if (back[x][node].empty()) dp[x][node][0] = 1;
		for (int before : back[x][node]) dp[x][node] |= dp[x][before] << 1;
		for (int next : g[x][node]) {
			in_degree[next]--;
			if (in_degree[next] == 0) q.push(next);
		}
	}
}

int main() {
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	cin >> n[0] >> n[1] >> m[0] >> m[1];
	gen(0);
	gen(1);
	// preprocessing all possible sums between the universes
	bitset<2001> ans;
	for (int i = 0; i < 1001; i++)
		if (dp[0][n[0]][i]) ans |= dp[1][n[1]] << i;
	int Q;
	cin >> Q;
	for (int i = 0; i < Q; i++) {
		int a;
		cin >> a;
		if (ans[a]) {
			cout << "Yes" << endl;
		} else {
			cout << "No" << endl;
		}
	}
	return 0;
}
```

</CPPSection>

<JavaSection>

```java
import java.io.*;
import java.util.*;

public class QuantumSuperposition {
	static int n[] = new int[2];
	static int m[] = new int[2];
	static ArrayList<Integer> g[][] = new ArrayList[2][1001];
	static ArrayList<Integer> back[][] = new ArrayList[2][1001];
	static boolean dp[][][] = new boolean[2][1001][2001];
	static Scanner scanner = new Scanner(System.in);

	static void gen(int x) {
		int[] in_degree = new int[1001];
		for (int i = 0; i < m[x]; i++) {
			int a = scanner.nextInt();
			int b = scanner.nextInt();
			g[x][a].add(b);
			back[x][b].add(a);
			in_degree[b]++;
		}
		// finding length of routes of first universe
		Queue<Integer> q = new LinkedList<>();
		for (int i = 0; i <= n[x]; i++) {
			if (in_degree[i] == 0) q.add(i);
		}
		while (!q.isEmpty()) {
			int node = q.poll();
			// using dp while processing the nodes topologically
			if (back[x][node].isEmpty()) dp[x][node][0] = true;
			for (int before : back[x][node]) {
				for (int i = 0; i < 2000; i++) {
					if (dp[x][before][i]) dp[x][node][i + 1] = true;
				}
			}
			for (int next : g[x][node]) {
				in_degree[next]--;
				if (in_degree[next] == 0) q.add(next);
			}
		}
	}

	public static void main(String[] args) throws IOException {
		n[0] = scanner.nextInt();
		n[1] = scanner.nextInt();
		m[0] = scanner.nextInt();
		m[1] = scanner.nextInt();
		for (int x = 0; x < 2; x++) {
			for (int i = 0; i < 1001; i++) {
				g[x][i] = new ArrayList<>();
				back[x][i] = new ArrayList<>();
			}
		}
		gen(0);
		gen(1);
		// preprocessing all possible sums between the universes
		boolean[] ans = new boolean[2001];
		for (int i = 0; i < 1001; i++) {
			if (dp[0][n[0]][i]) {
				for (int j = 0; j < 1001; j++) {
					if (dp[1][n[1]][j]) ans[i + j] = true;
				}
			}
		}
		int Q = scanner.nextInt();
		for (int i = 0; i < Q; i++) {
			int a = scanner.nextInt();
			if (ans[a]) {
				System.out.println("Yes");
			} else {
				System.out.println("No");
			}
		}
	}
}
```

</JavaSection>

<PySection>

```py
from collections import deque

n = [0, 0]
m = [0, 0]
g = [[[] for _ in range(1001)] for _ in range(2)]
back = [[[] for _ in range(1001)] for _ in range(2)]
dp = [[[False for _ in range(2001)] for _ in range(1001)] for _ in range(2)]


def gen(x):
	in_degree = [0] * 1001
	for _ in range(m[x]):
		a, b = map(int, input().split())
		g[x][a].append(b)
		back[x][b].append(a)
		in_degree[b] += 1
	# finding length of routes of first universe
	q = deque()
	for i in range(n[x] + 1):
		if in_degree[i] == 0:
			q.append(i)
	while q:
		node = q.popleft()
		# using dp while processing the nodes topologically
		if not back[x][node]:
			dp[x][node][0] = True
		for before in back[x][node]:
			for i in range(2000):
				if dp[x][before][i]:
					dp[x][node][i + 1] = True
		for nxt in g[x][node]:
			in_degree[nxt] -= 1
			if in_degree[nxt] == 0:
				q.append(nxt)


n[0], n[1], m[0], m[1] = map(int, input().split())
gen(0)
gen(1)
# preprocessing all possible sums between the universes
ans = [False for _ in range(2001)]
for i in range(1001):
	if dp[0][n[0]][i]:
		for j in range(1001):
			if dp[1][n[1]][j]:
				ans[i + j] = True

Q = int(input())
for _ in range(Q):
	a = int(input())
	if ans[a]:
		print("Yes")
	else:
		print("No")
```

</PySection>
