---
id: usaco-696
source: USACO Platinum 2017 January
title: Promotion Counting
author: Benjamin Qi, Timothy Gao, William Yuan
contributors: Vaishnav Krishnan
---

[Official Editorial (Java)](http://www.usaco.org/current/data/sol_promote_platinum_jan17.html)

## Solution 1: Euler Tour

**Time Complexity:** $\mathcal{O}(N\log N)$

Recall from the [Euler tour module](/gold/tree-euler) that each subtree is represented as a contiguous interval in its Euler tour. With this knowledge, we can compress the tree into an array. Now, the problem is reduced the following: for each node $i$, we need to determine the number of elements that are less than $\texttt{tour}[i]$ from $i$ to $\texttt{tout}[i]$, where $\texttt{tout}[i]$ is the end of the subtree interval for node $i$. By processing the nodes in decreasing order, this is a problem we can solve in $\mathcal{O}(N \log N)$ time with a binary-indexed tree.

<LanguageSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class PromotionCounting {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new FileReader("promote.in"));
		PrintWriter pw =
		    new PrintWriter(new BufferedWriter(new FileWriter("promote.out")));

		int N = Integer.parseInt(br.readLine());
		int[][] ratings = new int[N][2];
		for (int i = 0; i < N; i++) {
			ratings[i][0] = i;
			ratings[i][1] = Integer.parseInt(br.readLine());
		}
		List<Integer>[] adj = new List[N];

		for (int i = 0; i < adj.length; i++) { adj[i] = new ArrayList<>(); }

		for (int i = 1; i < N; i++) {
			int par = Integer.parseInt(br.readLine()) - 1;
			adj[par].add(i);
		}
		int[] ret = new int[N];
		int[] tout = new int[N];
		int[] bac = new int[N];
		dfs(adj, tout, bac, 0, 0, -1);
		BIT bit = new BIT(N);
		Arrays.sort(ratings, (int[] a, int[] b) -> b[1] - a[1]);

		for (int i = 0; i < N;) {
			int j = i;
			while (j < N && ratings[i][1] == ratings[j][1]) {
				int c = ratings[i][0];
				ret[c] = bit.sum(tout[c]) - bit.sum(bac[c] - 1);
				j++;
			}
			for (int k = i; k < j; k++) { bit.update(tout[ratings[k][0]], 1); }
			i = j;
		}

		for (int i : ret) { pw.println(i); }

		pw.close();
		br.close();
	}

	static int dfs(List<Integer>[] adj, int[] tout, int[] left, int idx, int cur,
	               int last) {
		left[cur] = idx;
		for (int n : adj[cur]) {
			if (n == last) continue;
			idx = dfs(adj, t, l, idx, n, cur);
		}
		tout[cur] = idx;
		return idx + 1;
	}

	static class BIT {
		public int[] bit;
		public BIT(int N) { bit = new int[N + 1]; }

		public int sum(int r) {
			r++;
			int ret = 0;
			while (r > 0) {
				ret += bit[r];
				r -= r & -r;
			}
			return ret;
		}

		public void update(int idx, int v) {
			idx++;
			while (idx < bit.length) {
				bit[idx] += v;
				idx += idx & -idx;
			}
		}
	}
}
```

</JavaSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAX_N = 1e5;
int n, t = 0;
vector<int> adj[MAX_N], out(MAX_N), in(MAX_N);

// BeginCodeSnip{BIT}
struct BIT {
	vector<int> bit;
	int n;

	BIT(int n) : n(n + 1), bit(n + 1) {}

	int sum(int r) {
		r++;
		int ret = 0;
		while (r > 0) {
			ret += bit[r];
			r -= r & -r;
		}
		return ret;
	}

	void update(int idx, int v) {
		idx++;
		while (idx < n) {
			bit[idx] += v;
			idx += idx & -idx;
		}
	}
};
// EndCodeSnip

void dfs(int cur, int prev) {
	in[cur] = t;
	for (int nxt : adj[cur]) {
		if (nxt != prev) { dfs(nxt, cur); }
	}
	out[cur] = t++;
}

int main() {
	freopen("promote.in", "r", stdin);
	cin >> n;
	vector<pair<int, int>> a(n);

	for (int i = 0; i < n; i++) {
		cin >> a[i].first;
		a[i].second = i;
	}

	for (int i = 1; i < n; i++) {
		int p;
		cin >> p;
		adj[--p].push_back(i);
	}

	dfs(0, -1);
	sort(a.rbegin(), a.rend());
	vector<int> ans(n + 1);
	BIT bit(n);
	for (int i = 0; i < n;) {
		int r = i;

		while (r < n && a[i].first == a[r].first) {
			ans[a[r].second] = bit.sum(out[a[r].second]) - bit.sum(in[a[r].second] - 1);
			r++;
		}

		for (int j = i; j < r; j++) bit.update(out[a[j].second], 1);

		i = r;
	}

	freopen("promote.out", "w", stdout);
	for (int i = 0; i < n; i++) cout << ans[i] << '\n';
}
```

</CPPSection>
</LanguageSection>

## Solution 2 (Merging Indexed Sets)

**Time Complexity:** $\mathcal{O}(N\log ^2N)$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

template <class T>
using Tree =
    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

const int MX = 1e5 + 5;
#define sz(x) (int)(x).size()

int N, a[MX], ind[MX], ans[MX], ret;
vector<int> child[MX];
Tree<int> d[MX];

void comb(int a, int b) {
	if (sz(d[a]) < sz(d[b])) d[a].swap(d[b]);
	for (int i : d[b]) d[a].insert(i);
}

void dfs(int x) {
	ind[x] = x;
	for (int i : child[x]) {
		dfs(i);
		comb(x, i);
	}
	ans[x] = sz(d[x]) - d[x].order_of_key(a[x]);
	d[x].insert(a[x]);
}

int main() {
	freopen("promote.in", "r", stdin);
	freopen("promote.out", "w", stdout);
	cin >> N;
	for (int i = 1; i <= N; ++i) cin >> a[i];
	for (int i = 2; i <= N; ++i) {
		int p;
		cin >> p;
		child[p].push_back(i);
	}
	dfs(1);
	for (int i = 1; i <= N; ++i) cout << ans[i] << "\n";
}
```

</CPPSection>
</LanguageSection>

Recall from the module that `std::swap(d[a],d[b])` will be too slow. However,
the following does (overloading `std::swap`):

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

template <class T>
using Tree =
    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

const int MX = 1e5 + 5;
#define sz(x) (int)(x).size()

int N, a[MX], ind[MX], ans[MX], ret;
vector<int> child[MX];
Tree<int> d[MX];

namespace std {
void swap(Tree<int> &a, Tree<int> &b) { a.swap(b); }
}  // namespace std

void comb(int a, int b) {
	if (sz(d[a]) < sz(d[b])) std::swap(d[a], d[b]);
	for (int i : d[b]) d[a].insert(i);
}

void dfs(int x) {
	ind[x] = x;
	for (int i : child[x]) {
		dfs(i);
		comb(x, i);
	}
	ans[x] = sz(d[x]) - d[x].order_of_key(a[x]);
	d[x].insert(a[x]);
}

int main() {
	freopen("promote.in", "r", stdin);
	freopen("promote.out", "w", stdout);
	cin >> N;
	for (int i = 1; i <= N; ++i) cin >> a[i];
	for (int i = 2; i <= N; ++i) {
		int p;
		cin >> p;
		child[p].push_back(i);
	}
	dfs(1);
	for (int i = 1; i <= N; ++i) cout << ans[i] << "\n";
}
```

</CPPSection>
</LanguageSection>

## Solution 3: HLD

**Time Complexity:** $\mathcal{O}(N\log ^2N)$

Sort the nodes from largest to smallest value, do path updates from each node to the root.

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

class segTree {
  private:
	vector<int> segtree;

  public:
	segTree(int N) {
		if (__builtin_popcount(N) > 1) N = 1 << (32 - __builtin_clz(N));
		segtree.resize(N << 1, 0);
	}
	void update(int i, int val) {
		for (i += (int)segtree.size() >> 1; i > 0; i >>= 1) segtree[i] += val;
	}
	int query(int l, int r) {
		int ans = 0;
		for (l += (int)segtree.size() >> 1, r += ((int)segtree.size() >> 1) + 1; l < r;
		     l >>= 1, r >>= 1) {
			if (l & 1) ans += segtree[l++];
			if (r & 1) ans += segtree[--r];
		}
		return ans;
	}
};

void dfs_hld(vector<vector<int>> &edges, vector<vector<int>> &heavy_paths,
             vector<int> &depth, vector<int> &sizes, int start) {
	int heavy_child = -1;
	++sizes[start];
	for (int i : edges[start]) {
		depth[i] = depth[start] + 1;
		dfs_hld(edges, heavy_paths, depth, sizes, i);
		sizes[start] += sizes[i];
		if (heavy_child == -1 || sizes[heavy_child] < sizes[i]) heavy_child = i;
	}
	if (heavy_child != -1) {
		swap(heavy_paths[start], heavy_paths[heavy_child]);
		heavy_paths[start].push_back(heavy_child);
	}
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	freopen("promote.in", "r", stdin);
	freopen("promote.out", "w", stdout);
	int N;
	cin >> N;
	vector<pair<int, int>> cow_proficiency(N, pair<int, int>());
	for (int i = 0; i < N; ++i) {
		cin >> cow_proficiency[i].first;
		cow_proficiency[i].second = i;
	}
	vector<vector<int>> edges(N, vector<int>()), heavy_paths(N, vector<int>());

	vector<int> sizes(N, 0), heavy_index(N, -1), path_index(N, -1), depth(N, 0),
	    parents(N, -1), ans(N, 0), cur_ans(N, 0);

	for (int i = 1; i < N; ++i) {
		cin >> parents[i];
		edges[--parents[i]].push_back(i);
	}

	dfs_hld(edges, heavy_paths, depth, sizes, 0);
	vector<segTree> segtrees(N, segTree(0));
	for (int i = 0; i < N; ++i) {
		reverse(heavy_paths[i].begin(), heavy_paths[i].end());
		for (int j = 0; j < (int)heavy_paths[i].size(); ++j) {
			heavy_index[heavy_paths[i][j]] = i;
			path_index[heavy_paths[i][j]] = j;
		}
		segtrees[i] = segTree((int)heavy_paths[i].size());
	}

	sort(cow_proficiency.begin(), cow_proficiency.end(), greater<pair<int, int>>());
	for (auto &p : cow_proficiency) {
		if (heavy_index[p.second] != -1) {
			ans[p.second] =
			    segtrees[heavy_index[p.second]].query(0, path_index[p.second]);
		} else ans[p.second] = cur_ans[p.second];
		p.second = parents[p.second];
		while (p.second >= 0) {
			if (heavy_index[p.second] != -1) {
				segtrees[heavy_index[p.second]].update(0, 1);
				if (path_index[p.second] + 1 <
				    (int)heavy_paths[heavy_index[p.second]].size()) {
					segtrees[heavy_index[p.second]].update(path_index[p.second] + 1,
					                                       -1);
				}
				p.second = parents[heavy_paths[heavy_index[p.second]][0]];
			} else {
				++cur_ans[p.second];
				p.second = parents[p.second];
			}
		}
	}
	for (int i = 0; i < N; ++i) cout << ans[i] << '\n';
	return 0;
}
```

</CPPSection>
</LanguageSection>
