---
id: usaco-993
source: USACO Gold 2020 January
title: Time is Mooney
author: Nathan Gong, Ryan Chou, David Guo
---

[Official Analysis (C++)](http://www.usaco.org/current/data/sol_time_gold_jan20.html)

## Explanation

The problem involves maximizing the profit Bessie can earn while traveling between cities and collecting moonies. We need to explore all paths while efficiently keeping track of the best outcomes. A dynamic programming approach is well-suited for this, as it allows us to break the problem into smaller subproblems: tracking the maximum moonies Bessie can have at each city for every possible day.

We define $dp[t][i]$ as the maximum moonies Bessie can have at city $i$ on day $t$. Starting with $dp[0][0] = 0$, we
iterate over each day up to $T_{\text{max}}$, the maximum number of days, and
over each city, updating $dp[t + 1][j]$ for all cities $j$ reachable from city
$i$ via a directed road. We compare the current value of $dp[t + 1][j]$ with the
value of coming from an adjacent city on the previous day,
$dp[t][i] + \text{moonies}[j]$, and take the maximum. After processing each day,
we calculate the profit as $dp[t][0] - C \cdot t^2$, representing the total
moonies minus the travel cost for $t$ days, and track the maximum profit. This
approach ensures we consider all feasible trips and ignore unreachable states.

## Implementation

**Time Complexity:** $\mathcal{O}(T_{\text{max}} \cdot (N + M))$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAX_DAYS = 1000;  // Maximum number of days Bessie can travel

int main() {
    freopen("time.in", "r", stdin);
    freopen("time.out", "w", stdout);
    
    int n, m, c;
    cin >> n >> m >> c;

    vector<int> moonies(n);
    for (int i = 0; i < n; i++) {
        cin >> moonies[i];
    }

    vector<vector<int>> adj(n);
    for (int i = 0; i < m; i++) {
        int a, b;
        cin >> a >> b;
        a--, b--; // Convert 1-indexed input to 0-indexed
        adj[a].push_back(b);
    }
    
    // dp[t][i]: max moonies at city i on day t
    vector<vector<int>> dp(MAX_DAYS, vector<int>(n, -1));
    dp[0][0] = 0;  // Base case: Start at city 0 (originally city 1) on day 0 with 0 moonies

    int res = 0;

    for (int t = 0; t < MAX_DAYS; t++) {
        for (int i = 0; i < n; i++) {
            // Skip cities that are unreachable on day t
            if (dp[t][i] == -1) {
                continue;
            }

            // Transition: Consider all roads from city i to its neighbors
            for (int j : adj[i]) {
                if (t + 1 < MAX_DAYS) {
                    // Update dp[t + 1][j] by considering a transition from an adjacent city on the previous day
                    dp[t + 1][j] = max(dp[t + 1][j], dp[t][i] + moonies[j]);
                }
            }
        }

        // Calculate profit if Bessie returns to city 0 (originally city 1) on day t
        res = max(res, dp[t][0] - c * t * t);
    }

    cout << res << "\n";
    return 0;
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class Main {
    static final int MAX_DAYS = 1000;  // Maximum number of days Bessie can travel
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new FileReader("time.in"));
        PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter("time.out")));
        
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        int c = Integer.parseInt(st.nextToken());

        int[] moonies = new int[n];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            moonies[i] = Integer.parseInt(st.nextToken());
        }

        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            adj.add(new ArrayList<>());
        }
        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken()) - 1;
            int b = Integer.parseInt(st.nextToken()) - 1;
            adj.get(a).add(b);
        }
        
        // dp[t][i]: max moonies at city i on day t
        int[][] dp = new int[MAX_DAYS][n];
        for (int[] row : dp) Arrays.fill(row, -1);
        dp[0][0] = 0;  // Base case: Start at city 0 (originally city 1) on day 0 with 0 moonies

        int res = 0;

        for (int t = 0; t < MAX_DAYS; t++) {
            for (int i = 0; i < n; i++) {
                // Skip cities that are unreachable on day t
                if (dp[t][i] == -1) {
                    continue;
                }

                // Transition: Consider all roads from city i to its neighbors
                for (int j : adj.get(i)) {
                    if (t + 1 < MAX_DAYS) {
                        // Update dp[t + 1][j] by considering a transition from an adjacent city on the previous day
                        dp[t + 1][j] = Math.max(dp[t + 1][j], dp[t][i] + moonies[j]);
                    }
                }
            }

            // Calculate profit if Bessie returns to city 0 (originally city 1) on day t
            res = Math.max(res, dp[t][0] - c * t * t);
        }

        pw.println(res);
        pw.close();
    }
}
```

</JavaSection>
<PySection>

```py
def main():
    with open("time.in", "r") as fin:
        n, m, c = map(int, fin.readline().split())
        moonies = list(map(int, fin.readline().split()))

        adj = [[] for _ in range(n)]
        for _ in range(m):
            a, b = map(int, fin.readline().split())
            a -= 1  # Convert 1-indexed input to 0-indexed
            b -= 1
            adj[a].append(b)

    MAX_DAYS = 1000  # Maximum number of days Bessie can travel
    
    # dp[t][i]: max moonies at city i on day t
    dp = [[-1] * n for _ in range(MAX_DAYS)]
    dp[0][0] = 0  # Base case: Start at city 0 (originally city 1) on day 0 with 0 moonies

    res = 0

    for t in range(MAX_DAYS):
        for i in range(n):
            # Skip cities that are unreachable on day t
            if dp[t][i] == -1:
                continue

            # Transition: Consider all roads from city i to its neighbors
            for j in adj[i]:
                if t + 1 < MAX_DAYS:
                    # Update dp[t + 1][j] by considering a transition from an adjacent city on the previous day
                    dp[t + 1][j] = max(dp[t + 1][j], dp[t][i] + moonies[j])

        # Calculate profit if Bessie returns to city 0 (originally city 1) on day t
        res = max(res, dp[t][0] - c * t * t)

    with open("time.out", "w") as fout:
        fout.write(f"{res}\n")

if __name__ == "__main__":
    main()
```

</PySection>
</LanguageSection>
