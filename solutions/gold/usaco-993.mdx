---
id: usaco-993
source: USACO Gold 2020 January
title: Time is Mooney
author: Nathan Gong, Ryan Chou, David Guo
---

[Official Analysis (C++)](http://www.usaco.org/current/data/sol_time_gold_jan20.html)

## Explanation

The problem involves maximizing the profit Bessie can earn while traveling
between cities and collecting moonies. We define $dp[t][i]$ as the maximum
moonies Bessie can have at city $i$ on day $t$. Starting with $dp[0][1] = 0$, we
iterate over each day up to $T_{\text{max}}$, the maximum number of days, and
over each city, updating $dp[t + 1][j]$ for all cities $j$ reachable from city
$i$ via a directed road. We compare the current value of $dp[t + 1][j]$ with the
value of coming from an adjacent city on the previous day,
$dp[t][i] + \text{moonies}[j]$, and take the maximum. After processing each day,
we calculate the profit as $dp[t][1] - C \cdot t^2$, representing the total
moonies minus the travel cost for $t$ days, and track the maximum profit. This
approach ensures we consider all feasible trips and ignore unreachable states.

## Implementation

**Time Complexity:** $\mathcal{O}(T_{\text{max}} \cdot (N + M))$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ifstream cin("time.in");
    ofstream cout("time.out");

    int n, m, c;
    cin >> n >> m >> c;

    vector<int> moonies(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> moonies[i];
    }

    vector<vector<int>> adj(n + 1);
    for (int i = 0; i < m; i++) {
        int a, b;
        cin >> a >> b;
        adj[a].push_back(b);
    }

    const int MAX_T = 1000;  // Maximum number of days Bessie can travel
    
    // DP table: dp[t][i] represents the maximum moonies Bessie can have at city i on day t
    vector<vector<int>> dp(MAX_T + 1, vector<int>(n + 1, -1));
    dp[0][1] = 0;  // Base case: Start at city 1 on day 0 with 0 moonies

    int res = 0;

    for (int t = 0; t <= MAX_T; t++) {
        for (int i = 1; i <= n; i++) {
            // Skip cities that are unreachable on day t
            if (dp[t][i] == -1) {
                continue;
            }

            // Transition: Consider all roads from city i to its neighbors
            for (int j : adj[i]) {
                if (t + 1 <= MAX_T) {
                    // Update dp[t + 1][j] by considering a transition from an adjacent city on the previous day
                    dp[t + 1][j] = max(dp[t + 1][j], dp[t][i] + moonies[j]);
                }
            }
        }

        // After processing all cities for day t, calculate the profit if Bessie returns to city 1
        res = max(res, dp[t][1] - c * t * t);
    }

    cout << res << "\n";
    return 0;
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class TimeIsMooney {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new FileReader("time.in"));
        PrintWriter pw = new PrintWriter(new FileWriter("time.out"));

        final int MAX_T = 1000;  // Maximum number of days Bessie can travel
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        int c = Integer.parseInt(st.nextToken());

        int[] moonies = new int[n + 1];
        st = new StringTokenizer(br.readLine());
        for (int i = 1; i <= n; i++) {
            moonies[i] = Integer.parseInt(st.nextToken());
        }

        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i <= n; i++) adj.add(new ArrayList<>());
        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());
            int u = Integer.parseInt(st.nextToken());
            int v = Integer.parseInt(st.nextToken());
            adj.get(u).add(v);
        }

        // DP table: dp[t][i] represents the maximum moonies Bessie can have at city i on day t
        long[][] dp = new long[MAX_T + 1][n + 1];
        for (int t = 0; t <= MAX_T; t++) {
            Arrays.fill(dp[t], -1);
        }
        dp[0][1] = 0;  // Base case: Start at city 1 on day 0 with 0 moonies

        long res = 0;

        for (int t = 0; t < MAX_T; t++) {
            for (int i = 1; i <= n; i++) {
                // Skip cities that are unreachable on day t
                if (dp[t][i] == -1) continue;

                // Transition: Consider all roads from city i to its neighbors
                for (int neighbor : adj.get(i)) {
                    if (t + 1 <= MAX_T) {
                        // Update dp[t + 1][neighbor] by considering a transition from an adjacent city on the previous day
                        dp[t + 1][neighbor] = Math.max(dp[t + 1][neighbor], dp[t][i] + moonies[neighbor]);
                    }
                }
            }

            // After processing all cities for day t, calculate the profit if Bessie returns to city 1
            res = Math.max(res, dp[t][1] - (long) c * t * t);
        }

        pw.println(res);
        pw.close();
    }
}
```

</JavaSection>
<PySection>

```py
MAX_DAYS = 1000

with open("time.in") as read:
    n, m, c = map(int, read.readline().strip().split())
    moonies = [0] + list(map(int, read.readline().strip().split()))

    adj = [[] for _ in range(n + 1)]
    for _ in range(m):
        u, v = map(int, read.readline().strip().split())
        adj[u].append(v)

# DP table: dp[t][i] represents the maximum moonies Bessie can have at city i on day t
dp = [[-1] * (n + 1) for _ in range(MAX_DAYS + 1)]
dp[0][1] = 0  # Base case: Start at city 1 on day 0 with 0 moonies

res = 0

for t in range(MAX_DAYS):
    for i in range(1, n + 1):
        # Skip cities that are unreachable on day t
        if dp[t][i] == -1:
            continue

        # Transition: Consider all roads from city i to its neighbors
        for neighbor in adj[i]:
            if t + 1 <= MAX_DAYS:
                # Update dp[t + 1][neighbor] by considering a transition from an adjacent city on the previous day
                dp[t + 1][neighbor] = max(dp[t + 1][neighbor], dp[t][i] + moonies[neighbor])

    # After processing all cities for day t, calculate the profit if Bessie returns to city 1
    res = max(res, dp[t][1] - c * t * t)

with open("time.out", "w") as write:
    write.write(f"{res}\n")
```

</PySection>
</LanguageSection>
