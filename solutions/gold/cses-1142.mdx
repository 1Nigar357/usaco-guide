---
id: cses-1142
source: CSES
title: Advertisement
author: Andi Qu, Benjamin Qi, Andrew Wang
---

**Time Complexity:** $\mathcal O(N)$.

## Solution 1

The largest rectangle must have the same height as the shortest bar that it
contains. For each $i$, consider the largest rectangle with height $H[i]$ such
that bar $i$ is the shortest bar it contains. The answer is simply the largest
of these $N$ rectangles.

Since the heights of these rectangles are fixed, we just want them to be as wide
as possible. Notice how the rectangle of bar $i$ is bounded by the the closest
shorter bars on each side of bar $i$ (or the ends of the histogram if these bars
don't exist).

We can use a monotone stack twice to find the closest shorter bars on each side
of each bar. See
[the stacks module](/gold/stacks#application-nearest-smaller-element)
for more details.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
  public:
	int largestRectangleArea(vector<int> &heights) {
		int n = heights.size();
		if (!n) return 0;
		stack<int> stck;
		vector<int> area(n, 0);
		for (int i = 0; i < n; i++) {
			while (stck.size() && heights[stck.top()] >= heights[i]) stck.pop();
			int width = i - (stck.size() ? stck.top() : -1);
			area[i] += width * heights[i];
			stck.push(i);
		}
		while (stck.size()) stck.pop();
		for (int i = n - 1; ~i; i--) {
			while (stck.size() && heights[stck.top()] >= heights[i]) stck.pop();
			int width = (stck.size() ? stck.top() : n) - i;
			area[i] += (width - 1) * heights[i];
			stck.push(i);
		}
		return *max_element(area.begin(), area.end());
	}
};
```

## Solution 2

Actually, we only need to go through the heights in one direction. When we see
`(i, heights[i])`, we process all rectangles with right end at `i-1` and height
greater than `heights[i]`. Note how we process the rectangles that end at the
last height by emptying the stack.

```cpp
#include <bits/stdc++.h>
using namespace std;
#define pi pair<int, int>
#define f first
#define s second
class Solution {
  public:
	int largestRectangleArea(vector<int> &heights) {
		int N = heights.size();
		int maxa = 0;
		stack<pi> sta;
		for (int i = 0; i < N; i++) {
			int start = i;
			while (!sta.empty() && heights[i] < sta.top().s) {
				pi cur = sta.top();
				sta.pop();
				start = cur.f;
				maxa = max(maxa, (i - cur.f) * cur.s);
			}
			sta.push(make_pair(start, heights[i]));
		}
		while (!sta.empty()) {
			pi cur = sta.top();
			sta.pop();
			maxa = max(maxa, (N - cur.f) * cur.s);
		}
		return maxa;
	}
};
```

Alternatively, one can add `-1` to the list of `heights` so we don't have
to treat rectangles that end at the last height in `heights` as a special case.

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;

int main() {
	int n;
	cin >> n;
	vector<ll> heights(n);
	for (ll& i : heights) {
		cin >> i;
	}
	heights.push_back(-1);

	stack<ll> mono_stack;
	mono_stack.push(-1);

	ll ans = 0;
	for (int i = 0; i <= n; i++) {
		while (mono_stack.top() != -1 &&
			   heights[mono_stack.top()] >= heights[i]) {
			int x = mono_stack.top();
			mono_stack.pop();
			// min height is heights[x]
			ll new_area = (i - 1 - mono_stack.top()) * heights[x];
			if (ans < new_area) {
				ans = new_area;
			}
		}
		mono_stack.push(i);
	}

	cout << ans << endl;
}
```
