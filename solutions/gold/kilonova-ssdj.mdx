---
id: kilonova-ssdj
source: Romania IOI selection test 2014
title: ssdj
author: Stefan Dascalescu
---

[Official Analysis (in Romanian)](https://github.com/roalgo-discord/Romanian-Olympiad-Solutions/blob/main/Baraj%20%2B%20Lot%20Seniori%20(IOI%20team%20selection%20tests)/2014/Lot%201/sol-ssdj.pdf)

## Explanation

Let's start from a more simple case, when the grid will only contain letters `a` and `b`. Let's associate for each letter a value corresponding to its position in the alphabet (for now, `a` equals $0$ and `b` equals $1$. Now we will have to find the number of submatrices such that we have ones in the top left and bottom right corners we have $1$ and we have $0$ everywhere else. 

Let's construct another grid of size $n \times n$ where $b(i, j)$ stores the number of consecutive $0$ on the column $j$ above the position $(i, j)$. 

Now for each line from $2$ to $n$, for a given position $(i, j) which is equal to $1$ (we will consider this the bottom-right corner), we will move from right to left on that line to find the values equal to $1$ placed at coordinates $(i, k)$ where $k < j$ such that $b(i, k) > 0$ and $b(i, k)$ strictly smaller than all values $b(i, p)$ with $p$ between $k+1$ and $j$.

The complexity of this approach is $\mathcal{O}(n^2)$.

Now we need to generalize for the entire grid, which has all lowercase letters of the alphabet. At each step, we fix a letter, let's call it $ch$. 

For that letter, we will now create a grid where the positions corresponding to all the letters which are smaller than $ch$ will be equal to $0$, all letters equal to $ch$ will be equal to $1$ and all letters greater than $ch$ will be equal to $2$.

Just like we did it for the binary grid, we will count how many submatrices have values equal to $0$ except for the two corners aforementioned. In order to avoid overcounting, we will only count the submatrices such that they contain $1$ in at least a corner. Now, when we process a position $(i, j)$ we will do as such: if on that position we have $1$, we will count the number of previous position which correspond to both $1$ and $2$, and if on the same position we have $2$, we will only count the previous positions that are equal to $1$.

The complexity of this approach is still $\mathcal{O}(n^2)$ for each letter, which gives us an overall complexity of $\mathcal{O}(sigma \times n^2)$, where $sigma = 26$ is the length of the alphabet.

## Implementation

**Time Complexity:** $\mathcal{O}(26 \cdot N^2)$

<LanguageSection>

<CPPSection>

#include<bits/stdc++.h>
using namespace std;
ifstream f("ssdj.in");
ofstream g("ssdj.out");
int n;
char mat[1002][1002];
int d[1002], ss;
int lst[1002][1002], lst2[1002][1002];
bool pus[1002][1002];
long long ans;
int main()
{
    f >> n;
    for(int i = 1; i <= n; ++i)
        f >> (mat[i] + 1);
    for(int i = 1; i <= n; ++i)
        lst2[n+1][i] = n+2;
    for(char i = 'z'; i >= 'a'; --i)
    {
        for(int R = 1; R <= n; ++R)
        {
            ss = 0;
            for(int S = 1; S <= n; ++S)
            {
                if(mat[R][S] >= i)
                    lst[R][S] = R;
                else
                    lst[R][S] = lst[R-1][S];
                while(ss && lst[R-1][S] >= lst[R][d[ss]])
                    --ss;
                if(mat[R][S] == i)
                {
                    ans += ss;
                    if(ss && d[1] == S)
                        --ans;
                }
                while(ss && lst[R][S] >= lst[R][d[ss]])
                    --ss;
                if(lst[R][S] <= (R - 1) && lst[R][S] != 0)
                    d[++ss] = S;
            }
        }
        for(int R = n; R >= 1; --R)
        {
            ss = 0;
            int hm = 0;
            for(int S = n; S >= 1; --S)
            {
                if(mat[R][S] >= i)
                    lst2[R][S] = R;
                else
                    lst2[R][S] = lst2[R+1][S];
                while(ss && lst2[R+1][S] <= lst2[R][d[ss]])
                {
                    if(mat[lst2[R][d[ss]]][d[ss]] == i)
                        --hm;
                    --ss;
                }
                if(mat[R][S] == i)
                {
                    int aa = ss;
                    ans += ss;
                    ans -= hm;
                    if(ss && d[ss] == S)
                        --ans, --aa;
                }
                while(ss && lst2[R][S] <= lst2[R][d[ss]])
                {
                    if(mat[lst2[R][d[ss]]][d[ss]] == i)
                        --hm;
                    --ss;
                }
                if(lst2[R][S] >= (R + 1) && lst2[R][S] != (n+2))
                {
                    if(mat[lst2[R][S]][S] == i)
                        ++hm;
                    d[++ss] = S;
                }
            }
        }
    }
    g << ans << '\n';
    return 0;
}

</CPPSection>

</LanguageSection>
