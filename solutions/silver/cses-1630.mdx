---
id: cses-1630
source: cses
title: Tasks & Deadlines
author: Rameez Parwez
---

[Unofficial Analysis](https://usaco.guide/CPH.pdf#p=70)

## Explanation

Notice that the meta is to process shorter tasks before longer tasks.

For some intuition regarding this, think of two tasks that take $5$ and $7$ time units to complete.
No matter what their respective rewards are, it's always optimal to complete the shorter task first.

<Spoiler title="Example">
Let's consider an example, where we are given 3 durations and deadlines and we need to find the maximum reward:

<center>
| Duration | Deadline |
| -------- | -------- |
|  6	   |	10	  |
|  8	   |	15	  |
|  5	   |	12	  |

</center>

From our intuition, the formula for calculating the maximum reward will look something like this:

$$
(\scriptsize{currentDeadline_1 - prefixSumDuration_1}) + \scriptsize{(currentDeadline_2 - prefixSumDuration_2)} + .... + \scriptsize{(currentDeadline_n - prefixSumDuration_n})
$$

There are three scenarios to consider:

- If we don't sort them and process them as they are, then our reward will be:
   $$
   (10 - 6) + (15 - 14) + (12 - 19) = -4
   $$

- If we sort them in decreasing order of duration, then our reward will be:
	$$
	(15 - 8) + (10 - 14) + (12 - 19) = -4
	$$

- If we sort them in increasing order of duration, then our reward will be:
    $$
	(12 - 5) + (10 - 11) + (15 - 19) = 2
	$$

Thus, from the above scenarios, we conclude that to get the maximum reward, we must sort them in increasing order of duration.
</Spoiler>

## Implementation

**Time complexity:** $\mathcal{O} (N \log N)$

<LanguageSection>
<CPPSection>

```cpp
#include <algorithm>
#include <iostream>
#include <vector>

using std::cout;
using std::endl;

int main() {
	int task_num;
	std::cin >> task_num;
	std::vector<std::pair<int, int>> tasks(task_num);
	for (auto &[duration, deadline] : tasks) {
		std::cin >> duration >> deadline;
	}

	std::sort(tasks.begin(), tasks.end());

	long long time = 0;
	long long reward = 0;
	for (const auto &[duration, deadline] : tasks) {
		time += duration;
		reward += deadline - time;
	}

	cout << reward << endl;
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class TasksNDeadlines {
	public static void main(String[] args) throws IOException {
		BufferedReader read =
		    new BufferedReader(new InputStreamReader(System.in));
		int taskNum = Integer.parseInt(read.readLine());
		int[][] tasks = new int[taskNum][];
		for (int t = 0; t < taskNum; t++) {
			StringTokenizer task = new StringTokenizer(read.readLine());
			tasks[t] = new int[] {
			    Integer.parseInt(task.nextToken()),  // duration
			    Integer.parseInt(task.nextToken())   // deadline
			};
		}

		Arrays.sort(tasks, Comparator.comparingInt(t -> t[0]));

		long time = 0;
		long reward = 0;
		for (int[] t : tasks) {
			time += t[0];
			reward += t[1] - time;
		}

		System.out.println(reward);
	}
}
```

</JavaSection>
<PySection>

<Warning>

Due to Python's constant factor, the below code may TLE on a couple of test cases.

</Warning>

```py
tasks = []
for _ in range(int(input())):
	duration, deadline = [int(i) for i in input().split()]
	tasks.append((duration, deadline))

tasks.sort()

time = 0
reward = 0
for duration, deadline in tasks:
	time += duration
	reward += deadline - time

print(reward)
```

</PySection>
</LanguageSection>
