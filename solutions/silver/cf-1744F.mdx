---
id: cf-1744F
source: CF
title: MEX vs MED
author: Alex Du
---

## Explanation

[Official Analysis](https://codeforces.com/blog/entry/108101)

<Spoiler title="Hint 1">

To find subsegments with a given value of $\texttt{mex}$, we must find subsegments which contain all
integers $0, 1, \ldots, \texttt{mex}-1$, while also not containing $\texttt{mex}$.

</Spoiler>

<Spoiler title="Hint 2">

For a subsegment of length $\leq 2 \cdot \texttt{mex}$, the condition $\texttt{mex} > \texttt{med}$ will be satisfied, since the median can be at most $\texttt{mex}-1$.

</Spoiler>

<Spoiler title="Solution">

We will iterate  $\texttt{mex}$ from $1$ to $n-1$, finding all valid subsegments of that $\texttt{mex}$ at a time.

Let $l$ and $r$ represent the highest left bound and the lowest right bound respectively of a subsegment that satisfies a given $\texttt{mex}$, and $\texttt{pos}$ represent  the index of $\texttt{mex}$. If we know $l$, $r$, and $\texttt{pos}$, then we can quickly count the subsegments for a given $\texttt{mex}$.


First, if $\texttt{pos}$ is between $l$ and $r$, the number of valid subsegments with this $\texttt{mex}$ is zero since the $\texttt{mex}$ of this subsegment is greater than the $\texttt{mex}$ we are looking for.


We need to find all subsegments of length $\leq 2 \cdot \texttt{mex}$ that contain $l \ldots r$ that don't include $\texttt{pos}$. Say $\texttt{pos}>r$, since we only need to change our approach slightly if $\texttt{pos} < l$. We can increment $r$ from $r$ to $\texttt{pos}-1$ fast enough, since each time we increment we increase the size of our subsegment by $1$, for a maximum of $N$ times.

Considering this new bound of $r$, we can find the number of possible values of $l$ that form a valid subsegment. We know that the $\texttt{mex}$ is correct for this right bound of $r$ and all left bounds $\leq l$, since the original $l \ldots r$ covered $0, 1, \ldots, \texttt{mex} - 1$, and $\texttt{pos} > r$. Therefore, we need to find the number of positions $\leq l$ such that $r-l+1 \leq \texttt{mex} \cdot 2$. The lower
bound of our smallest value of $l$ is $r-\texttt{mex} \cdot 2 + 1$, which we can find by rearranging the previous inequality.

Note that if this value is negative, we should set it to $0$. After this, we know that all values between $l$ and this smallest $l$ are valid left bounds for our given $r$ so that we can add $l-\texttt{smallest\_l} + 1$. Again, note that if $l < \texttt{smallest\_l}$, which will happen in the case that our subsegment is too big for our current $\texttt{mex}$, we should instead add $0$.

We can do the same if $\texttt{pos} < l$, by decrementing from $l$ to $\texttt{pos}+1$ with minimal changes to the math. To quickly find the next position of $\texttt{mex}$, we can store the position of each integer.


## Implementation

**Time Complexity:** $\mathcal{O}(N)$


<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>

using namespace std;

using ll = long long;

int main() {
	int test_num;
	cin >> test_num;
	for (int t = 0; t < test_num; t++) {
		int n;
		cin >> n;

		// stores position of integer
		vector<int> pos(n);

		for (int i = 0; i < n; i++) {
			int x;
			cin >> x;
			pos[x] = i;
		}

		// initialize left and right bounds for mex
		int l = pos[0], r = pos[0];
		ll ans = 1;

		// mex represents the current mex l and r cover
		for (int mex = 1; mex < n; mex++) {
			int next_pos = pos[mex];

			// skip if next_pos is already between l and r
			if (l <= next_pos && next_pos <= r) { continue; }

			/*
			 * Since we can create a valid subsegment for a given mex up until
			 * size mex * 2, our max difference between l and r is mex * 2 - 1.
			 */
			int max_diff = mex * 2 - 1;

			if (next_pos < l) {
				for (; l > next_pos; l--) {
					int largest_r = min(l + max_diff, n - 1);
					// add all possible right bounds that don't change the
					// current mex
					ans += max(largest_r - r + 1, 0);
				}
			} else {
				for (; r < next_pos; r++) {
					int smallest_l = max(r - max_diff, 0);
					// add all possible left bounds that don't change the
					// current mex
					ans += max(l - smallest_l + 1, 0);
				}
			}
		}

		cout << ans << '\n';
	}
}
```

</CPPSection>

</LanguageSection>

</Spoiler>
