---
id: cf-803D
source: CF
title: Magazine Ad
author: Alex Du
---

<Spoiler title="Hint 1">

Is there a way to format an ad of a given width using less than or equal to the maximum number of lines?

</Spoiler>

<Spoiler title="Solution">

## Explanation

[Official Analysis](https://codeforces.com/blog/entry/51768)

If we can find whether formatting an ad with a given width within the line constraints is possible, then we can binary search on the width, printing the minimum width that works.

Note that spaces function identically to hyphens, so we can treat them the same way. We can break the ad into blocks of word lengths, with each word length including the word plus a space or hyphen. The only exception is the last word, which will not have either.

Given a width, we will add as many words as possible to each line, creating a new line when we run out of room. If the number of lines we use is less than or equal to the maximum number of lines, then our width is fine. Note that if any individual word is wider than our given width, we must use a greater width.

## Implementation

**Time Complexity:** $\mathcal{O}(N \log N)$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int max_lines;
vector<int> word_lengths;
string ad;

/** @return if most optimized ad of given width satisfies constraints */
bool width_valid(int width) {
	int lines = 0;
	int cur_width = 0;

	for (int word_length : word_lengths) {
		// if individual word is wider than ad width, we need a greater width
		if (word_length > width) { return false; }

		// if we overflow, we need a new line
		if (cur_width + word_length > width) {
			lines++;
			cur_width = word_length;
		} else {
			cur_width += word_length;  // add word to current line
		}
	}

	if (cur_width > 0) { lines++; }
	return lines <= max_lines;
}

int main() {
	cin >> max_lines;
	// ignore '\n' character before getline
	cin.ignore();
	getline(cin, ad);

	// get sizes of each word, including trailing spaces and trailing hyphens
	word_lengths.push_back(0);
	for (char i : ad) {
		word_lengths.back()++;
		// spaces and hyphens work the same, start new word after adding char
		if (i == ' ' || i == '-') { word_lengths.push_back(0); }
	}

	/*
	 * find the lowest width that doesn't use greater than max_lines
	 * binary search: https://usaco.guide/silver/binary-search
	 */
	int lo = 0;
	int hi = (int)ad.size();
	hi++;
	while (lo < hi) {
		int mid = lo + (hi - lo) / 2;
		if (width_valid(mid)) {
			hi = mid;
		} else {
			lo = mid + 1;
		}
	}

	cout << lo << endl;
}
```

</CPPSection>
</LanguageSection>

</Spoiler>
