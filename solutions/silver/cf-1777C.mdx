---
id: cf-1777C
source: CF
title: Quiz Master
author: Rameez Parwez
---

[Official Editorial (C++)](https://codeforces.com/blog/entry/111729)

## Explanation

A team is considered to be proficient if every number from $1$ to $m$ is covered by at least one of the student's smartness value. We will use a two-pointer approach on the sorted smartness values to minimize the maximum difference between any two students while ensuring the team covers all topics. A topic is covered if it's a factor of at least one student's smartness. We will keep track of this using a frequency array $cnt$ to count how many times each topic is covered and a variable ${topics\_covered}$ to count how many topics are fully covered.

At first, when we add a student to the team we iterate through all the factors of their smartness (up to $m$) and update $cnt$. If a topic is covered for the first time (i.e., $cnt[x] = 1$) we increase
${topics\_covered}$ counter. Once all topics are covered, we calculate the difference between the current team's maximum and minimum smartness values and store the minimum difference encountered.

Similarly, we do this when we remove a student from the team, but this time, instead of increasing $cnt$, we decrease it. If a topic's frequency becomes $0$, we decrement ${topics\_covered}$, indicating that topic is no longer covered.

We keep sliding the pointers and repeating this process to find the smallest range where all topics are covered.

## Implementation

**Time Complexity:** $\mathcal{O}(n \log(n) + n \cdot \sqrt{M})$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>

const int M = 1e5;
std::vector<int> factors[M + 1];

int main() {

	// Precompute factors for all numbers from 1 to M
	for (int i = 1; i <= M; i++) {
		for (int j = i; j <= M; j += i) { factors[j].push_back(i); }
	}

	int test_case;
	std::cin >> test_case;
	while (test_case-- > 0) {
		int n, m;
		std::cin >> n >> m;
		std::vector<int> arr(n), cnt(m + 1);
		for (int &x : arr) { std::cin >> x; }

		std::sort(begin(arr), end(arr));
		int topics_covered = 0;
		int res = INT_MAX;

		for (int i = 0, j = 0; i < n; i++) {
			// adding student
			while (j < n and topics_covered < m) {
				for (int x : factors[arr[j]]) {
					if (x <= m) {
						cnt[x]++;
						if (cnt[x] == 1) {  // topic x covered for the first time
							topics_covered += 1;
						}
					}
				}
				j++;
			}
			if (topics_covered == m) { res = std::min(arr[j - 1] - arr[i], res); }

			// removing student
			for (auto x : factors[arr[i]]) {
				if (x <= m) {
					cnt[x]--;
					if (cnt[x] == 0) {  // topic x no longer covered
						topics_covered -= 1;
					}
				}
			}
		}
		std::cout << (res == INT_MAX ? -1 : res) << '\n';
	}
}
```

</CPPSection>
<PySection>

```py
M = 10**5
factors = [[] for _ in range(M + 1)]

# Precompute factors for all numbers from 1 to M
for i in range(1, M + 1):
	for j in range(i, M + 1, i):
		factors[j].append(i)

for _ in range(int(input())):
	n, m = map(int, input().split())
	arr = list(map(int, input().split()))

	arr.sort()
	cnt = [0] * (m + 1)
	topics_covered = 0
	res = float("inf")
	j = 0

	for i in range(n):
		# adding student
		while j < n and topics_covered < m:
			for x in factors[arr[j]]:
				if x <= m:
					cnt[x] += 1
					if cnt[x] == 1:  # topic x covered for the first time
						topics_covered += 1

			j += 1

		if topics_covered == m:
			res = min(res, arr[j - 1] - arr[i])

		# removing student
		for x in factors[arr[i]]:
			if x <= m:
				cnt[x] -= 1
				if cnt[x] == 0:  # topic x no longer covered
					topics_covered -= 1

	print(-1 if res == float("inf") else res)
```

</PySection>
</LanguageSection>
