---
id: cf-1368D
source: CF
title: AND, OR and square sum
author: Paul Chen
---

[Official Analysis](https://codeforces.com/blog/entry/79027)

# Explanation

**Observation 1**: Notice that $x \ AND \ y + x \ OR \ y = x + y$, so the total sum of all the elements never changes.

**Observation 2**: Notice that during each operation, the number and position of the set bits don't change. For instance, let $x = 110_2$, $y = 101_2$. $x \ AND \ y = 100_2$, and $x \ OR \ y = 111_2$. Before and after the operation, there are two $1$ bits that are set, one $2$ bit that is set, and one $4$ bit that is set.

**Observation 3**: Notice when performing an operation, $\sum_{i=1}^{n}{a_i^2}$ increases when $|x - y|$ increases. Thus, we want to keep performing operations such that $|x - y|$ increases. In fact, because $x \ AND \ y \leq \min(x, y)$ and $x \ OR \ y \geq \max(x, y)$, performing an operation will never decrease $|x - y|$.

Therefore, the optimal configuration occurs when it is impossible to change $|x - y|$ with more operations. This happens when, for any two values $a_i$ and $a_j$, $a_i \ AND \ a_j = \min(a_i, a_j)$, and $a_i \ OR \ a_j = \max(a_i, a_j)$. In other words, when we sort the optimal configuration in ascending order, $a_i \ AND \ a_{i + 1} = a_i$.

The optimal configuration can be built by handling each bit separately. This approach takes into account Observation 2, which states that no operations will alter the bits. For instance, consider the array, `[1, 5, 4, 7, 3]`. In binary form, it is represented as `[001, 101, 100, 111, 011]`. To structure this array optimally, move all the set bits to one end. This results in the reconfigured array: `[000, 001, 101, 111, 111]`. In decimal form, this new array reads `[0, 1, 5, 7, 7]`. Finally, find the sum of squares of the elements in this new array. The resulting total provides the desired solution.

## Implementation

**Time Complexity:** $\mathcal{O}(N)$


<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int n;
	cin >> n;
	vector<int> a(n);
	for (int i = 0; i < n; i++) {
		cin >> a[i];
	}

	// Count the number of set bits at each position.
	vector<int> num_bits(20);
	for (int i = 0; i < 20; i++) {
		for (int j = 0; j < n; j++) {
			if (a[j] & (1ll << i)) {
				num_bits[i]++;
			}
		}
	}

	// Create the optimal array and calculate the sum of the squares of the new
	// array.
	long long ans = 0;
	for (int i = 0; i < n; i++) {
		long long new_val = 0;
		for (int j = 0; j < 20; j++) {
			if (num_bits[j]) {
				new_val |= (1ll << j);
				num_bits[j]--;
			}
		}
		ans += new_val * new_val;
	}
	cout << ans << "\n";
}
```

</CPPSection>

<JavaSection>

```java
import java.io.*;
import java.util.*;

class AndOrSquareSum {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		int n = sc.nextInt();
		int[] a = new int[n];
		for (int i = 0; i < n; i++) {
			a[i] = sc.nextInt();
		}

		// Count the number of set bits at each position.
		int[] num_bits = new int[20];
		for (int i = 0; i < 20; i++) {
			for (int j = 0; j < n; j++) {
				if ((a[j] & (1L << i)) != 0) {
					num_bits[i]++;
				}
			}
		}

		// Create the optimal array and calculate the sum of the squares of the
		// new array.
		long ans = 0;
		for (int i = 0; i < n; i++) {
			long new_val = 0;
			for (int j = 0; j < 20; j++) {
				if (num_bits[j] != 0) {
					new_val |= (1L << j);
					num_bits[j]--;
				}
			}
			ans += new_val * new_val;
		}

		System.out.println(ans);
	}
}
```

</JavaSection>

<PySection>

```py
n = int(input())
a = list(map(int, input().split()))

# Count the number of set bits at each position.
num_bits = [0]*20
for i in range(20):
	for j in range(n):
		if a[j] & (1 << i):
			num_bits[i] += 1

# Create the optimal array and calculate the sum of the squares of the new array.
ans = 0
for i in range(n):
	curr = 0
	for j in range(20):
		if num_bits[j]:
			curr |= (1 << j)
			num_bits[j] -= 1
	ans += curr * curr

print(ans)
```

</PySection>

</LanguageSection>
