---
id: usaco-895
source: USACO Silver 2019 January
title: Icy Perimeter
author: Tanish Tyagi, Brad Ma, Juheon Rhee, David Guo
---

[Official Analysis (C++)](http://www.usaco.org/current/data/sol_perimeter_silver_jan19.html)

## Explanation

We can use Breadth-First Search (BFS) to explore each blob, starting from an unvisited '#' cell. During BFS, we can calculate the blobâ€™s area by counting the number of '#' cells visited and determine its perimeter by counting the number of adjacent cells, reducing the count for each shared edge with neighboring '#' cells. As we traverse the grid, we can initiate a BFS for each unvisited '#' cell to compute the area and perimeter of all blobs. We can track the largest area found, and if multiple blobs share the same largest area, we can choose the one with the smallest perimeter. Finally, we output the largest area and the corresponding smallest perimeter.

## Implementation

**Time Complexity:** $\mathcal{O}(N^2)$

<LanguageSection>

<JavaSection>

```java
import java.io.*;
import java.util.*;

public class IcyPerimeter {
	// Movement directions (up, down, left, right)
	private static final int[][] DIRECTIONS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

	private static int[] bfs(int row, int col, char[][] grid, boolean[][] visited,
	                         int n) {
		Deque<int[]> q = new ArrayDeque<>();
		q.add(new int[] {row, col});  // Start BFS from the given cell (row, col)

		int area = 0;
		int perimeter = 0;

		while (!q.isEmpty()) {
			int[] current = q.poll();  // Current cell (row, col)
			row = current[0];
			col = current[1];

			// Skip if the cell has already been visited
			if (visited[row][col]) { continue; }

			visited[row][col] = true;  // Mark the cell (row, col) as visited
			area++;  // Increment area (each '#' contributes 1 to the area)

			int sides =
			    4;  // Each cell starts with 4 sides contributing to the perimeter
			for (int[] direction : DIRECTIONS) {
				int nextRow = row + direction[0];
				int nextCol = col + direction[1];

				// Check if the neighboring cell is within the grid
				if (nextRow >= 0 && nextRow < n && nextCol >= 0 && nextCol < n) {
					// If the neighbor (nextRow, nextCol) is part of the same blob
					if (grid[nextRow][nextCol] == '#') {
						// Add the neighbor (nextRow, nextCol) to the queue
						q.add(new int[] {nextRow, nextCol});
						sides--;  // Shared edges reduce the perimeter contribution
					}
				}
			}
			perimeter += sides;  // Add remaining sides to the perimeter
		}

		return new int[] {area, perimeter};
	}

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new FileReader("perimeter.in"));
		PrintWriter pw =
		    new PrintWriter(new BufferedWriter(new FileWriter("perimeter.out")));

		int n = Integer.parseInt(br.readLine());

		char[][] grid = new char[n][n];
		boolean[][] visited = new boolean[n][n];

		for (int i = 0; i < n; i++) {
			String line = br.readLine();
			grid[i] = line.toCharArray();
		}

		int maxArea = 0;
		int minPerimeter = Integer.MAX_VALUE;

		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				if (grid[i][j] == '#' && !visited[i][j]) {
					int[] result = bfs(i, j, grid, visited, n);
					int area = result[0];
					int perimeter = result[1];

					// Update maxArea and minPerimeter based on the BFS results
					if (area > maxArea ||
					    (area == maxArea && perimeter < minPerimeter)) {
						maxArea = area;
						minPerimeter = perimeter;
					}
				}
			}
		}

		pw.println(maxArea + " " + minPerimeter);
		pw.close();
	}
}
```

</JavaSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

// Movement directions (up, down, left, right)
const vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

pair<int, int> bfs(int row, int col, vector<vector<char>> &grid,
                   vector<vector<bool>> &visited, int n) {
	queue<pair<int, int>> q;
	q.push({row, col});  // Start BFS from the given cell (row, col)

	int area = 0;
	int perimeter = 0;

	while (!q.empty()) {
		auto [row, col] = q.front();  // Current cell (row, col)
		q.pop();

		// Skip if the cell has already been visited
		if (visited[row][col]) { continue; }

		visited[row][col] = true;  // Mark the cell (row, col) as visited
		area++;  // Increment area (each '#' contributes 1 to the area)

		int sides = 4;  // Each cell starts with 4 sides contributing to the perimeter
		for (auto [dx, dy] : directions) {
			int next_row = row + dx, next_col = col + dy;

			// Check if the neighboring cell is within the grid
			if (next_row >= 0 && next_row < n && next_col >= 0 && next_col < n) {
				// If the neighbor (next_row, next_col) is part of the same blob
				if (grid[next_row][next_col] == '#') {
					// Add the neighbor (next_row, next_col) to the queue
					q.push({next_row, next_col});
					sides--;  // Shared edges reduce the perimeter contribution
				}
			}
		}
		perimeter += sides;  // Add remaining sides to the perimeter
	}

	return {area, perimeter};
}

int main() {
	freopen("perimeter.in", "r", stdin);
	freopen("perimeter.out", "w", stdout);

	int n;
	cin >> n;

	vector<vector<char>> grid(n, vector<char>(n));
	vector<vector<bool>> visited(n, vector<bool>(n, false));

	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) { cin >> grid[i][j]; }
	}

	int max_area = 0;
	int min_perimeter = INT_MAX;

	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			if (grid[i][j] == '#' && !visited[i][j]) {
				const auto [area, perimeter] = bfs(i, j, grid, visited, n);
				// Update max_area and min_perimeter based on the BFS results
				if (area > max_area ||
				    (area == max_area && perimeter < min_perimeter)) {
					max_area = area;
					min_perimeter = perimeter;
				}
			}
		}
	}

	cout << max_area << " " << min_perimeter << "\n";
	return 0;
}
```

</CPPSection>

<PySection>

```py
from collections import deque

# Movement directions (up, down, left, right)
directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]


def bfs(row, col, grid, visited, n):
	queue = deque()
	queue.append((row, col))  # Start BFS from the given cell (row, col)

	area = 0
	perimeter = 0

	while queue:
		row, col = queue.popleft()  # Current cell (row, col)

		# Skip if the cell has already been visited
		if visited[row][col]:
			continue

		visited[row][col] = True  # Mark the cell (row, col) as visited
		area += 1  # Increment area (each '#' contributes 1 to the area)

		sides = 4  # Each cell starts with 4 sides contributing to the perimeter
		for dx, dy in directions:
			next_row = row + dx
			next_col = col + dy

			# Check if the neighboring cell is within the grid
			if 0 <= next_row < n and 0 <= next_col < n:
				# If the neighbor (next_row, next_col) is part of the same blob
				if grid[next_row][next_col] == "#":
					# Add the neighbor (next_row, next_col) to the queue
					queue.append((next_row, next_col))
					sides -= 1  # Shared edges reduce the perimeter contribution
		perimeter += sides  # Add remaining sides to the perimeter

	return area, perimeter


with open("perimeter.in", "r") as fin:
	n = int(fin.readline().strip())
	grid = [list(fin.readline().strip()) for _ in range(n)]

visited = [[False] * n for _ in range(n)]

max_area = 0
min_perimeter = float("inf")

for i in range(n):
	for j in range(n):
		if grid[i][j] == "#" and not visited[i][j]:
			area, perimeter = bfs(i, j, grid, visited, n)
			# Update max_area and min_perimeter based on the BFS results
			if area > max_area or (area == max_area and perimeter < min_perimeter):
				max_area = area
				min_perimeter = perimeter

print(f"{max_area} {min_perimeter}", file=open("perimeter.out", "w"))
```
</PySection>

</LanguageSection>
