---
id: usaco-1159
source: USACO Silver 2021 December
title: Connecting Two Barns
author: Nathan Gong, Jesse Choe
---

[Official Analysis (C++)](http://usaco.org/current/data/sol_prob2_silver_dec21.html)

## Implementation - DFS + Two Pointers

**Time Complexity:** $\mathcal{O}(T\cdot (N + M))$

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;
using vll = vector<long long>;
using vvll = vector<vector<long long>>;
#define f(i, to) for (int i = 0; i < (to); ++i)
constexpr ll INFL = 0x3f3f3f3f3f3f3f3f;

ll t, n, m;
void solve() {
    cin>>n>>m;
    vvll adj(n);
    f(i, m) {
        ll u, v; cin>>u>>v; u--; v--;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    vll vis(n, -1);
    ll cnt = 0;
    f(i, n) {
        if(vis[i]!=-1) continue;
        // Run dfs, mapping each node to its connected component
        stack<ll> s; s.push(i);
        while(!s.empty()) {
            ll u = s.top(); s.pop();
            if(vis[u]!=-1) continue; vis[u] = cnt;
            for(ll v : adj[u]) s.push(v);
        }
        cnt++;
    }
    vvll mp(cnt);
    f(i, n) mp[vis[i]].push_back(i);

	// Components for the start and end barn
    vll b1 = mp[vis[0]];
    vll b2 = mp[vis[n-1]];

	// Distances to b1 and b2
    vll dist1(cnt, INFL);
    vll dist2(cnt, INFL);

	// If we have a better option within the component (shorter distance) take it.
	// This pointer method works because component nodes are ordered
    ll a=0;
    f(i, n) {
        ll dist = abs(b1[a]-i);
        while(a < b1.size()-1 && abs(b1[a+1]-i)<dist) a++;
        dist1[vis[i]] = min(dist1[vis[i]], dist);
    }
    ll b=0;
    f(i, n) {
        ll dist = abs(b2[b]-i);
        while(b < b2.size()-1 && abs(b2[b+1]-i) < dist) b++;
        dist2[vis[i]] = min(dist2[vis[i]], dist);
    }

    ll res = INFL;
    f(i, cnt) {
        res = min(res, dist1[i]*dist1[i] + dist2[i]*dist2[i]);
    }
    cout<<res<<'\n';
}

int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    cin>>t;
    f(i, t) solve();
}
```

</CPPSection>

<JavaSection>

```java
import java.io.*;
import java.util.*;

public class ConnectingTwoBarns {
	public static void main(String[] args) {
		Kattio io = new Kattio();
		int t = io.nextInt();
		for (int test = 0; test < t; test++) {
			int n = io.nextInt();
			int m = io.nextInt();

			List<List<Integer>> adj = new ArrayList<>();
			for (int i = 0; i < n; i++) { adj.add(new ArrayList<>()); }
			for (int i = 0; i < m; i++) {
				int a = io.nextInt() - 1;
				int b = io.nextInt() - 1;
				adj.get(a).add(b);
				adj.get(b).add(a);
			}

			// stores the component each node is in
			int[] visited = new int[n];

			int numComponents = 0;
			Arrays.fill(visited, -1);
			for (int i = 0; i < n; i++) {
				// run DFS on node if it hasn't been visited
				if (visited[i] == -1) {
					Stack<Integer> stack = new Stack<>();
					stack.push(i);
					while (!stack.isEmpty()) {
						int curr = stack.pop();
						if (visited[curr] != -1) continue;

						// mark node as visited
						visited[curr] = numComponents;

						for (int neighbor : adj.get(curr)) { stack.push(neighbor); }
					}
					numComponents++;
				}
			}

			// stores a list of nodes for each component
			List<List<Integer>> components = new ArrayList<>();
			for (int i = 0; i < numComponents; i++) {
				components.add(new ArrayList<>());
			}
			/*
			 * add each field to its connected component; since we're iterating
			 * from 0...n-1, each component will be guaranteed to be in sorted
			 * order
			 */
			for (int i = 0; i < n; i++) { components.get(visited[i]).add(i); }

			// the components containing the two barns
			List<Integer> barn1 = components.get(visited[0]);
			List<Integer> barn2 = components.get(visited[n - 1]);
			// min dist between each intermediate component and the two barns
			long[] dist1 = new long[numComponents];
			long[] dist2 = new long[numComponents];
			Arrays.fill(dist1, Integer.MAX_VALUE);
			Arrays.fill(dist2, Integer.MAX_VALUE);

			// use two pointer to populate dist1
			int barn1Index = 0;
			for (int i = 0; i < n; i++) {
				int dist = Math.abs(barn1.get(barn1Index) - i);

				/*
				 * if the distance between i and the current field in barn1's
				 * component is larger than the distance between i and the next
				 * field in barn1's component, increment barn1Index until this
				 * no longer holds true
				 */
				while (
				    // make sure we don't go out of bounds
				    barn1Index < barn1.size() - 1 &&
				    Math.abs(barn1.get(barn1Index + 1) - i) < dist) {
					barn1Index++;
				}

				/*
				 * we've now found the field in barn 1's component that's
				 * closest to i
				 *
				 * we can use this to update the minimum distance between field
				 * i's component and barn 1's component
				 */
				dist1[visited[i]] = Math.min(dist, dist1[visited[i]]);
			}

			// use two pointer to populate dist2
			int barn2Index = 0;
			for (int i = 0; i < n; i++) {
				int dist = Math.abs(barn2.get(barn2Index) - i);

				while (barn2Index < barn2.size() - 1 &&
				       Math.abs(barn2.get(barn2Index + 1) - i) < dist) {
					barn2Index++;
				}
				dist2[visited[i]] = Math.min(dist, dist2[visited[i]]);
			}

			// calculate minimum cost
			long min = Long.MAX_VALUE;
			for (int i = 0; i < numComponents; i++) {
				long cost = dist1[i] * dist1[i] + dist2[i] * dist2[i];
				min = Math.min(min, cost);
			}
			io.println(min);
		}
		io.close();
	}

	// CodeSnip{Kattio}
}
```

</JavaSection>

</LanguageSection>

## Alternative Implementation - DFS + Binary Search

As the editorial mentioned, we can minimize the cost function by using binary
search. Since each conncected component array is in sorted order (if we add the
nodes of each connected component in increasing order), we can binary search on
the sorted connected component array to find the closest field $j$ for each
field $i$ using `std::lower_bound`.

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;

const int MAX_N = 1e5;

vector<int> adj[MAX_N];
// List of all the components of the farm
vector<int> comps[MAX_N];
// Given a node, returns the index of the component it belongs to
int comp[MAX_N];

// DFS to find the connected components
void dfs(int cur, int c) {
	if (comp[cur] != -1) { return; }
	comp[cur] = c;
	for (int u : adj[cur]) { dfs(u, c); }
}

ll cost(int a, int b) {
	int dist = MAX_N;
	for (int u : comps[a]) {
		/*
		 * Finds the closest field in bs' connected
		 * component to field u and updates the minimum
		 * distance. The closest field is found by binary
		 * searching on a sorted array (bs' connected
		 * component).
		 */
		int i = lower_bound(comps[b].begin(), comps[b].end(), u) - comps[b].begin();
		if (i > 0) { dist = min(dist, abs(comps[b][i - 1] - u)); }
		if (i < comps[b].size()) { dist = min(dist, abs(comps[b][i] - u)); }
	}
	/*
	 * Returns the minimum cost of building a path
	 * between the two components (aka dist^2)
	 */
	return (ll)dist * dist;
}

void solve() {
	int n, m;
	cin >> n >> m;

	// Resets our variables for each test case
	for (int i = 0; i < n; i++) {
		comp[i] = -1;
		adj[i].clear();
		comps[i].clear();
	}

	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		adj[--a].push_back(--b);
		adj[b].push_back(a);
	}

	/*
	 * Stores the number of connected components
	 * (set to -1 so that we don't overcount)
	 */
	int cur = -1;
	// Uses DFS to find each connected component
	for (int i = 0; i < n; i++) {
		if (comp[i] == -1) { dfs(i, ++cur); }
	}

	/*
	 * Add each field to its connected component.
	 * Since we're iterating from 0...n-1, each
	 * connected component is guaranteed to be
	 * in sorted order
	 */
	for (int i = 0; i < n; i++) { comps[comp[i]].push_back(i); }

	/*
	 * The initial answer is set to the cost of building
	 * a direct path between fields 1 and N. This also
	 * takes care of the case when fields 1 and N are in
	 * the same connected component.
	 */
	ll res = cost(comp[0], comp[n - 1]);
	for (int c = 1; c < cur; c++) {
		// Minimize the cost of building two paths
		res = min(res, cost(c, comp[0]) + cost(c, comp[n - 1]));
	}
	cout << res << endl;
}

int main() {
	int t;
	cin >> t;
	for (int i = 0; i < t; i++) { solve(); }
}
```

</CPPSection>

</LanguageSection>
